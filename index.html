<!doctype html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Redirect Match</title>

  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --text:#0f172a;
      --muted:#64748b;
      --border:#e5e7eb;

      --accent:#2563eb;
      --accent-600:#1d4ed8;

      --ok:#16a34a;
      --warn:#f59e0b;
      --err:#dc2626;

      --chip:#eef2ff;
      --shadow:0 10px 30px #0000000a;
    }

    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text)}
    a{color:var(--accent);text-decoration:none}
    .container{max-width:1100px;margin:0 auto;padding:0 20px}

    /* Topbar */
    .topbar{
      position:sticky;top:0;z-index:40;
      background:rgba(255,255,255,.85);
      backdrop-filter:saturate(180%) blur(10px);
      border-bottom:1px solid var(--border)
    }
    .nav{display:flex;align-items:center;justify-content:space-between;height:60px}
    .brand{display:flex;align-items:center;gap:10px;font-weight:800;letter-spacing:.2px}
    .brand .logo{width:10px;height:24px;background:var(--accent);border-radius:4px}

    .actions{display:flex;align-items:center;gap:10px}
    .user{font-size:13px;color:var(--muted)}

    .btn{cursor:pointer;border:none;border-radius:10px;font-weight:700;padding:10px 14px}
    .btn.primary{background:var(--accent);color:#fff}
    .btn.primary:hover{background:var(--accent-600)}
    .btn.ghost{background:#fff;border:1px solid var(--border);color:var(--text)}
    .btn.ghost:hover{background:#fafafa}
    .btn.danger{background:#fff;border:1px solid #fecaca;color:#991b1b}
    .btn.danger:hover{background:#fff5f5}
    .btn.mini{padding:8px 10px;border-radius:10px;font-size:13px;font-weight:700}
    .hidden{display:none !important}

    /* Tabs */
    .tabs{display:flex;gap:8px;border-bottom:1px solid var(--border);padding:14px 0;margin:0 0 16px 0;flex-wrap:wrap}
    .tab{
      padding:8px 12px;border-radius:999px;background:#fff;color:var(--text);
      cursor:pointer;border:1px solid var(--border);font-weight:800;font-size:13px
    }
    .tab.active{background:var(--accent);color:#fff;border-color:var(--accent)}
    .tab-panel{display:none}
    .tab-panel.active{display:block}

    /* Layout / cards */
    .page{padding:18px 0 36px}
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      padding:16px;
      box-shadow:var(--shadow)
    }
    .section-title{font-weight:900;margin:0 0 10px 0;display:flex;align-items:center;gap:10px}
    .sub{margin-top:6px;color:var(--muted);line-height:1.45;font-size:13px}

    .row{display:flex;gap:12px;flex-wrap:wrap}
    .grow{flex:1 1 260px}

    input[type=text],input[type=url],input[type=number],input[type=email],input[type=password],textarea{
      width:100%;padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:#fafafa;color:var(--text)
    }
    input[type=file]{width:100%}

    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px;font-weight:700}

    .badge{
      display:inline-block;padding:4px 10px;border-radius:999px;font-size:12px;
      border:1px solid var(--border);background:#fff;color:var(--muted);font-weight:800
    }
    .badge.ok{background:#dcfce7;color:#065f46;border-color:#bbf7d0}
    .badge.err{background:#fee2e2;color:#991b1b;border-color:#fecaca}
    .badge.info{background:#eff6ff;color:#1e3a8a;border-color:#bfdbfe}
    .badge.warn{background:#fffbeb;color:#92400e;border-color:#fde68a}

    /* Tables */
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px;border-bottom:1px solid var(--border);text-align:left;vertical-align:top}
    th{font-size:12px;color:var(--muted);font-weight:900;background:#fafafa}
    td{font-size:13px}
    .table-wrap{overflow:auto;border:1px solid var(--border);border-radius:14px;background:#fff}

    .switch{appearance:none;width:42px;height:24px;background:#e5e7eb;border-radius:999px;position:relative;outline:none;cursor:pointer;transition:.2s}
    .switch:checked{background:var(--accent)}
    .switch:before{content:"";position:absolute;left:3px;top:3px;width:18px;height:18px;background:#fff;border-radius:999px;transition:.2s;box-shadow:0 1px 3px #0001}
    .switch:checked:before{left:21px}

    details{background:#fafafa;border:1px solid var(--border);border-radius:14px;padding:12px}
    summary{cursor:pointer;font-weight:900}
    .help{font-size:12px;color:var(--muted)}

    /* Progress bar */
    #progressBar{
      background: var(--accent);
      border-radius: 999px;
      transition: width .25s ease;
    }

    /* Blur background when gate is open */
    #appShell.blurred{
      filter: blur(6px);
      pointer-events: none;
      user-select: none;
    }

    /* Auth Gate */
    #gate{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(15,23,42,.25);z-index:80}
    #gate .card{width:min(520px, calc(100% - 24px));box-shadow:0 30px 80px #00000033}

    /* Modal (alerts + confirm + rename) */
    #modal.hidden{display:none !important;}
    #modal{position:fixed;inset:0;z-index:90}
    .m-backdrop{position:absolute;inset:0;background:rgba(15,23,42,.45)}
    .m-box{
      position:relative;
      width:min(560px, calc(100% - 26px));
      margin:80px auto;
      background:#fff;border:1px solid var(--border);border-radius:16px;
      box-shadow:0 30px 80px #00000033;overflow:hidden
    }
    .m-head{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:flex-start;gap:12px}
    .m-title{font-weight:900}
    .m-body{padding:16px;color:var(--text);font-size:14px;line-height:1.5}
    .m-foot{padding:14px 16px;border-top:1px solid var(--border);display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap}

    /* Run Summary Modal */
    #runSummaryModal.hidden{display:none !important;}
    #runSummaryModal{position:fixed;inset:0;z-index:85;}
    .rs-backdrop{position:absolute;inset:0;background:rgba(15,23,42,.45);}

    /* IMPORTANT: modal scrollable (pour voir le bas) */
    .rs-modal{
      position:relative;
      width:min(760px, calc(100% - 28px));
      margin:40px auto;
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow:0 30px 80px #00000033;
      overflow:hidden;

      display:flex;
      flex-direction:column;
      max-height: calc(100vh - 80px);
    }
    .rs-header{
      flex:0 0 auto;
      display:flex;align-items:flex-start;justify-content:space-between;gap:12px;
      padding:16px 16px;
      border-bottom:1px solid var(--border);
      background:rgba(255,255,255,.9);
    }
    .rs-title{font-weight:900;font-size:18px;margin:0;color:var(--text)}
    .rs-subtitle{margin-top:4px;color:var(--muted);font-size:13px;line-height:1.35}

    .rs-body{
      flex:1 1 auto;
      padding:16px;
      display:grid;
      gap:12px;
      overflow:auto; /* <- scroll interne */
    }

    .rs-kpis{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px;}
    @media (max-width:720px){
      .rs-kpis{grid-template-columns:1fr;}
      .rs-modal{ margin:16px auto; max-height: calc(100vh - 32px); }
    }
    .rs-kpi{border:1px solid var(--border);border-radius:12px;padding:12px;background:#fafafa;}
    .rs-kpi .label{font-size:12px;color:var(--muted);margin-bottom:6px;font-weight:900}
    .rs-kpi .value{font-size:20px;font-weight:900;color:var(--text);line-height:1}
    .rs-kpi .hint{margin-top:6px;font-size:12px;color:var(--muted)}
    .rs-callout{border:1px solid #bfdbfe;background:#eff6ff;color:#1e3a8a;border-radius:12px;padding:12px;font-size:13px;line-height:1.35;font-weight:800}
    .rs-table{width:100%;border-collapse:separate;border-spacing:0;border:1px solid var(--border);border-radius:12px;overflow:hidden;}
    .rs-table th,.rs-table td{padding:10px;border-bottom:1px solid var(--border);vertical-align:top;}
    .rs-table th{font-size:12px;color:var(--muted);font-weight:900;background:#fafafa;}
    .rs-table tr:last-child td{border-bottom:none;}
    .rs-url{word-break:break-word;color:var(--text);font-size:12px;line-height:1.35;}

    .rs-footer{
      flex:0 0 auto;
      display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;
      padding:14px 16px;border-top:1px solid var(--border);background:#fff;
    }

    /* Footer */
    .footer{margin:22px 0 0;color:var(--muted);font-size:12px}

    /* ✅ Logout mini loader */
    .spinner{
      width:14px;height:14px;
      border:2px solid #cbd5e1;
      border-top-color: var(--accent);
      border-radius:999px;
      display:inline-block;
      animation:spin .7s linear infinite;
      vertical-align:-2px;
      margin-right:8px;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    window.SUPABASE_URL="https://srvvdrhiaygklqjijdtq.supabase.co";
    window.SUPABASE_PUBLISHABLE_KEY="sb_publishable_Tm5K5o-Fq_UBHP9Qp6JBog_rtKQjpDi";
  </script>
</head>

<body>
  <!-- Topbar -->
  <div class="topbar">
    <div class="container nav">
      <div class="brand">
        <div class="logo"></div><span>Redirect Match</span>
      </div>

      <div class="actions">
        <span id="currentUser" class="user"></span>
        <button id="btnLoginOpen" class="btn primary">Se connecter</button>

        <!-- Historique en haut à droite (uniquement connecté) -->
        <button id="btnHistoryTop" class="btn ghost hidden">Historique</button>

        <button id="btnLogout" class="btn ghost hidden">Se déconnecter</button>
      </div>
    </div>
  </div>

  <!-- Auth Gate -->
  <div id="gate" class="hidden">
    <div class="card">
      <div class="section-title" style="font-size:18px;margin-bottom:6px">Connexion</div>
      <div class="sub">Connecte-toi pour lancer un matching et accéder à ton historique.</div>

      <div class="row" style="margin-top:12px">
        <div class="grow">
          <label>Email</label>
          <input id="authEmail" type="email" placeholder="you@domain.tld">
        </div>
        <div class="grow">
          <label>Mot de passe</label>
          <input id="authPassword" type="password" placeholder="••••••••">
        </div>
      </div>

      <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap">
        <button class="btn primary" id="btnLogin">Se connecter</button>
        <button class="btn ghost" id="btnSignup">Créer un compte</button>
        <button class="btn ghost" id="btnGateClose" type="button">Fermer</button>
      </div>

      <div id="authStatus" class="sub" style="margin-top:10px"></div>
    </div>
  </div>

  <!-- Generic Modal -->
  <div id="modal" class="hidden">
    <div class="m-backdrop" id="mBackdrop"></div>
    <div class="m-box" role="dialog" aria-modal="true">
      <div class="m-head">
        <div>
          <div class="m-title" id="mTitle">Info</div>
          <div class="sub" id="mSubtitle" style="margin-top:6px"></div>
        </div>
        <button class="btn ghost mini" id="mClose" type="button">Fermer</button>
      </div>
      <div class="m-body" id="mBody"></div>
      <div class="m-foot" id="mFoot"></div>
    </div>
  </div>

<div id="appShell">

  <!-- Main -->
  <div class="container page">

    <!-- Tabs (Historique accessible via bouton topbar) -->
    <div class="tabs">
      <button class="tab active" data-tab="config">Paramètres</button>
      <button class="tab" data-tab="test">Diagnostic URL</button>
      <button class="tab" data-tab="matching">Traitement</button>
    </div>

    <!-- Panel: Configuration -->
    <section id="panel-config" class="tab-panel active">
      <div class="card">
        <div class="section-title">
          Paramètres
          <span id="prefilterBadge" class="badge info" title="Le filtrage automatique est activé si au moins une liste de mots est cochée.">Filtrage : désactivé</span>
        </div>
        <div class="sub">Optionnel : listes de mots, traductions, parents. Les fichiers sont validés dès l’import (colonnes/onglets).</div>

        <div class="row" style="margin-top:14px">
          <div class="grow">
            <label>Listes de mots (Excel) — colonnes = noms des listes, lignes = “clé, syn1, syn2…”</label>
            <input id="fileDico" type="file" accept=".xlsx,.xls" />
            <div id="dicoStatus" class="sub"></div>
          </div>

          <div class="grow">
            <label>Traductions Excel (colonnes <code>SOURCE</code> et <code>TRANSLATION</code>)</label>
            <input id="fileTrad" type="file" accept=".xlsx,.xls" />
            <div id="tradStatus" class="sub"></div>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <div class="grow">
            <label>Parents (optionnel) – Excel avec colonne <code>URL</code></label>
            <input id="fileParents" type="file" accept=".xlsx,.xls" />
            <div id="parentsStatus" class="sub"></div>
          </div>
        </div>

        <details style="margin-top:14px" open>
          <summary>Réglages avancés</summary>

          <div class="row" style="margin-top:12px">
            <div class="grow"><label>Mots à ignorer (séparés par des virgules)</label><input id="inpStop" type="text" /></div>
            <div class="grow"><label>Mots à ne pas modifier (séparés par des virgules)</label><input id="inpExc" type="text" /></div>
          </div>

          <div class="row" style="margin-top:10px">
            <div class="grow"><label>Expressions multi-mots (virgules)</label><input id="inpMulti" type="text" /></div>
            <div class="grow"><label>Regex référence</label><input id="inpRegex" type="text" value="(?i)ref[:\\- ]?([a-z0-9\\-]+)" /></div>
            <div class="grow"><label>Score minimum</label><input id="inpMin" type="number" step="0.1" value="0.5" /></div>
            <div class="help" style="margin-top:6px">Informationnel : ce seuil n’est pas utilisé comme filtre dans le moteur.</div>

          </div>

          <!-- Scoring mots + importance du sens -->
          <div class="row" style="margin-top:10px">
            <div class="grow">
              <label>Importance du sens dans le résultat</label>
              <input id="inpSemanticWeight" type="number" step="1" value="80" />
              <div class="help" style="margin-top:6px">Plus la valeur est élevée, plus l’outil se base sur le sens des mots (et pas seulement sur les mots identiques).</div>
            </div>
            <div class="grow">
              <label>Bonus si les mêmes mots apparaissent</label>
              <input id="inpTokenBonus" type="number" step="1" value="5" />
              <div class="help" style="margin-top:6px">Ajoute un bonus pour chaque mot présent à la fois dans l’URL à corriger et l’URL proposée.</div>
            </div>
            <div class="grow">
              <label>Pénalité si l’URL proposée ajoute des mots</label>
              <input id="inpTokenMalus" type="number" step="1" value="-10" />
              <div class="help" style="margin-top:6px">Retire des points pour chaque mot présent dans l’URL proposée mais absent de l’URL à corriger (valeur négative attendue).</div>
            </div>
          </div>

          <div style="margin-top:14px">
            <div class="section-title" style="margin-bottom:8px">Listes de mots (bonus / pénalité)</div>
            <div class="help" style="margin-bottom:10px">Ajuste l’importance de chaque liste et active/désactive son utilisation.</div>

            <div class="table-wrap">
              <table id="tblDico">
                <thead>
                  <tr>
                    <th>Liste</th>
                    <th style="width:130px">Bonus</th>
                    <th style="width:130px">Pénalité</th>
                    <th style="width:120px">Utiliser</th>
                    <th style="width:140px">Entrées</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </details>

        <div style="margin-top:14px;display:flex;gap:10px;flex-wrap:wrap;align-items:center">
          <button class="btn ghost" id="btnApply">Appliquer</button>
          <span id="cfgStatus" class="badge info hidden"></span>
        </div>
      </div>
    </section>

    <!-- Panel: Test URL -->
    <section id="panel-test" class="tab-panel">
      <div class="card">
        <div class="section-title">Diagnostic URL</div>
        <div class="sub">Teste comment l’outil comprend et transforme une URL.</div>

        <div class="row" style="margin-top:14px">
          <div class="grow"><label>URL</label><input id="testUrl" type="text" placeholder="https://www.exemple.com/produit/ref-AB1234?color=red"></div>
          <button class="btn primary" id="btnTest" style="align-self:flex-end">Tester</button>
        </div>

        <div style="margin-top:12px">
          <label>Résultat</label>
          <textarea id="testOut" readonly style="min-height:160px"></textarea>
        </div>
      </div>
    </section>

    <!-- Panel: Matching -->
    <section id="panel-matching" class="tab-panel">
      <div class="card">
        <div class="section-title">Traitement</div>
        <div class="sub">Importe les URLs à corriger et les URLs valides (validés à l’import), puis lance le traitement. Le résultat est stocké dans ton historique.</div>

        <div class="row" style="margin-top:14px">
          <div class="grow">
            <label>Fichier des URLs à corriger (onglet <code>404</code>, colonne <code>URL_404</code>)</label>
            <input id="file404" type="file" accept=".xlsx,.xls" />
            <div id="f404Status" class="sub"></div>
          </div>

          <div class="grow">
            <label>Fichier des URLs valides (onglet <code>200</code>, colonne <code>URL_200</code>)</label>
            <input id="file200" type="file" accept=".xlsx,.xls" />
            <div id="f200Status" class="sub"></div>
          </div>
        </div>

        <div style="margin-top:14px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end">
          <span id="runStatus" class="badge info hidden"></span>
          <button class="btn ghost" id="btnClear">Réinitialiser</button>
          <button class="btn primary" id="btnRun">Lancer</button>
        </div>

        <!-- Progress (barre + temps + estimation) -->
        <div id="progressWrap" class="hidden" style="margin-top:12px">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px">
            <span id="progressLabel" class="sub" style="margin:0">Traitement…</span>
            <span id="progressPct" class="badge info">0%</span>
          </div>

          <div style="height:10px;background:#eef2ff;border:1px solid var(--border);border-radius:999px;overflow:hidden">
            <div id="progressBar" style="height:100%;width:0%"></div>
          </div>

          <div class="help" style="margin-top:8px;display:flex;gap:12px;flex-wrap:wrap">
            <span>Temps écoulé : <b id="elapsedTxt">0s</b></span>
            <span>Estimation : <b id="etaTxt">—</b></span>
          </div>
        </div>

        <!-- Download immédiat (local) -->
        <div id="downloadWrap" class="hidden" style="margin-top:14px; display:flex; gap:10px; align-items:center; justify-content:flex-end;flex-wrap:wrap">
          <span id="downloadLabel" class="badge ok"></span>
          <button class="btn ghost" id="btnDownload" type="button">Télécharger</button>
        </div>
      </div>
    </section>

    <!-- Panel: Historique (accessible via bouton topbar) -->
    <section id="panel-history" class="tab-panel">
      <div class="card">
        <div class="section-title" style="justify-content:space-between;align-items:center;">
          <span>Historique</span>
          <div style="display:flex;gap:10px;flex-wrap:wrap">
            <button class="btn ghost mini" id="btnHistoryRefresh" type="button">Rafraîchir</button>
          </div>
        </div>
        <div class="sub">Nom du run + date + fichiers. Tu peux renommer et supprimer un run.</div>

        <div style="margin-top:12px" class="table-wrap">
          <table id="tblHistory">
            <thead>
              <tr>
                <th style="width:220px">Date</th>
                <th style="width:260px">Nom</th>
                <th>Run</th>
                <th style="width:260px">Fichiers</th>
                <th style="width:320px">Actions</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div id="historyStatus" class="sub" style="margin-top:10px"></div>
      </div>
    </section>

    <div class="footer">© Redirect Match</div>
  </div>

  <!-- Run Summary Modal (PRO) -->
  <div id="runSummaryModal" class="hidden">
    <div class="rs-backdrop" id="runSummaryBackdrop"></div>

    <div class="rs-modal" role="dialog" aria-modal="true" aria-labelledby="rsTitle">
      <div class="rs-header">
        <div>
          <div id="rsTitle" class="rs-title">Récap du run</div>
          <div id="rsSubtitle" class="rs-subtitle"></div>
        </div>
        <button id="btnRunSummaryClose" class="btn ghost" type="button">Fermer</button>
      </div>

      <div class="rs-body" id="runSummaryContent"></div>

      <div class="rs-footer">
        <button id="btnRunSummaryDownload" class="btn primary" type="button">Télécharger le résultat</button>
        <button id="btnRunSummaryOk" class="btn ghost" type="button">OK</button>
      </div>
    </div>
  </div>

<script>
/* ===================== Supabase Auth + Client + ROUTING (CORRIGÉ + ANTI-FREEZE + UX LOGOUT) ===================== */
const supabaseClient = window.supabase.createClient(
  window.SUPABASE_URL,
  window.SUPABASE_PUBLISHABLE_KEY,
  { auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true } }
);

const elGate = document.getElementById('gate');
const elLoginOpen = document.getElementById('btnLoginOpen');
const elLogout = document.getElementById('btnLogout');
const elUser = document.getElementById('currentUser');
const elHistoryTop = document.getElementById('btnHistoryTop');
const appShell = document.getElementById('appShell');

function setGateMsg(msg){ const el=document.getElementById('authStatus'); if(el) el.textContent=msg||''; }
function busyAuth(on){ ['btnLogin','btnSignup'].forEach(id=>{const b=document.getElementById(id); if(b) b.disabled=!!on; }); }

/* ---- anti-freeze helpers ---- */
function withTimeout(promise, ms = 8000){
  return Promise.race([
    promise,
    new Promise((_, reject)=> setTimeout(()=> reject(new Error('Timeout')), ms))
  ]);
}
async function getSessionSafe(){
  try{
    const { data } = await withTimeout(supabaseClient.auth.getSession(), 8000);
    return data?.session || null;
  }catch{
    return null;
  }
}

/* ✅ Logout UX: spinner + texte */
const logoutOriginalText = elLogout?.textContent || 'Se déconnecter';
function setLogoutPending(on){
  if(!elLogout) return;
  if(on){
    elLogout.disabled = true;
    elLogout.innerHTML = `<span class="spinner"></span>Déconnexion…`;
  }else{
    elLogout.disabled = false;
    elLogout.textContent = logoutOriginalText;
  }
}

function openGate({ closable = true } = {}){
  elGate.classList.remove('hidden');
  appShell?.classList.add('blurred');
  const closeBtn = document.getElementById('btnGateClose');
  if(closeBtn) closeBtn.classList.toggle('hidden', !closable);
}
function closeGate(){
  elGate.classList.add('hidden');
  appShell?.classList.remove('blurred');
}

function normPath(){
  const p = (location.pathname || '/').replace(/\/+$/, '');
  return p === '' ? '/' : p;
}
function isLoginRoute(){
  const p = normPath().toLowerCase();
  return p === '/login';
}

/* ✅ route(sessionOverride) pour éviter les boucles getSession() */
async function route(sessionOverride = null){
  const session = sessionOverride ?? await getSessionSafe();
  const authed = !!session;

  if (isLoginRoute()){
    if (authed){
      history.replaceState({}, '', '/');
      closeGate();
      return;
    }
    setGateMsg('');
    openGate({ closable: false });
    return;
  }

  if (!authed){
    closeGate();
    return;
  }

  closeGate();
}

/* Support éventuels tokens dans l’URL (magic link, etc.) */
(async function bootstrapFromHash(){
  const hash=new URLSearchParams(location.hash.slice(1));
  const access_token=hash.get('access_token');
  const refresh_token=hash.get('refresh_token');
  if(access_token && refresh_token){
    try{ await supabaseClient.auth.setSession({access_token,refresh_token}); }
    catch{}
    finally{ history.replaceState(null,'',location.pathname+location.search); }
  }
})();

async function requireAuthOrGate(message){
  const session = await getSessionSafe();
  if(!session){
    setGateMsg(message || 'Connecte-toi pour continuer.');
    openGate({ closable: true });
    return null;
  }
  return session;
}

/* ✅ applyAuthUI(sessionOverride) + ✅ ne rien afficher quand déconnecté */
async function applyAuthUI(sessionOverride = null){
  const session = sessionOverride ?? await getSessionSafe();
  const authed = !!session;

  // ✅ Demande: ne rien afficher en haut à droite quand déconnecté
  elUser.textContent = authed ? `Connecté : ${session.user.email}` : '';

  elLogout.classList.toggle('hidden', !authed);
  elLoginOpen.classList.toggle('hidden', authed);
  elHistoryTop.classList.toggle('hidden', !authed);

  const historyPanel = document.getElementById('panel-history');
  if (authed && historyPanel?.classList.contains('active')) {
    loadHistory().catch(()=>{});
  }
}

/* ✅ onAuthStateChange fournit session: on la réutilise (pas de getSession en boucle) */
supabaseClient.auth.onAuthStateChange(async (event, session)=> {
  if (event === 'SIGNED_IN' || event === 'SIGNED_OUT') {
    CURRENT_USER_ID = session?.user?.id || null;
    loadLocalForUser(CURRENT_USER_ID);
    hydrateUIFromState();
  } else if (event === 'TOKEN_REFRESHED') {
    // Ne pas reset le state : on garde les dicos en mémoire
    CURRENT_USER_ID = session?.user?.id || CURRENT_USER_ID;
  }

  await applyAuthUI(session || null);
  await route(session || null);
});



/* ✅ Login (anti-freeze + utilise data.session direct) */
document.getElementById('btnLogin')?.addEventListener('click', async ()=>{
  const email=document.getElementById('authEmail').value.trim();
  const password=document.getElementById('authPassword').value;
  if(!email||!password) return setGateMsg('Renseigne email et mot de passe.');

  setGateMsg('Connexion…'); busyAuth(true);
  try{
    const { data, error } = await withTimeout(
      supabaseClient.auth.signInWithPassword({ email, password }),
      12000
    );
    if(error) return setGateMsg('Erreur: '+error.message);

    const session = data?.session || null;

    setGateMsg('Connecté.');
    await applyAuthUI(session);

    /* IMPORTANT: après login, on sort de /login immédiatement + on ferme */
    history.replaceState({}, '', '/');
    closeGate();

    loadHistory().catch(()=>{});
  }catch(e){
    setGateMsg('Erreur: '+(e?.message || String(e)));
  }finally{
    busyAuth(false);
  }
});

/* Signup (avec timeout aussi) */
document.getElementById('btnSignup')?.addEventListener('click', async ()=>{
  const email=document.getElementById('authEmail').value.trim();
  const password=document.getElementById('authPassword').value;
  if(!email||!password) return setGateMsg('Renseigne email et mot de passe (min. 6 caractères).');

  setGateMsg('Création du compte…'); busyAuth(true);
  try{
    const { error } = await withTimeout(
      supabaseClient.auth.signUp({
        email,
        password,
        options:{ emailRedirectTo: `${location.origin}/login` }
      }),
      12000
    );
    if(error) return setGateMsg('Erreur: '+error.message);
    setGateMsg('Compte créé. Vérifie ton email.');
  }catch(e){
    setGateMsg('Erreur: '+(e?.message || String(e)));
  }finally{
    busyAuth(false);
  }
});

/* ✅ CLIC TOPBAR : ouvre immédiatement la pop-up + met /login */
elLoginOpen.addEventListener('click', (e)=>{
  e.preventDefault();

  setGateMsg('');
  openGate({ closable: false });

  if (!isLoginRoute()){
    history.pushState({}, '', '/login');
  }

  route().catch(()=>{});
});

document.getElementById('btnGateClose')?.addEventListener('click', ()=>{
  if (isLoginRoute()){
    history.pushState({}, '', '/');
    route().catch(()=>{});
    return;
  }
  closeGate();
  setGateMsg('');
});


function hardResetUIAndLocal(){
  try{
  // supprime les settings du user courant + legacy
  localStorage.removeItem(getSettingsKey(CURRENT_USER_ID));
  localStorage.removeItem('matcherFront'); // legacy (si tu l’as eu avant)
}catch{}

  // 2) reset état mémoire
  state.dicos = {};
  state.dicoWeights = {};
  state.translations = {};
  state.parents = [];
  state.cfg = {
    stop: new Set(),
    exc: new Set(),
    multi: [],
    ref: '(?i)ref[:\\- ]?([a-z0-9\\-]+)',
    min: 0.5,
    semanticWeight: 80,
    tokenBonus: 5,
    tokenMalus: -10
  };

  // 3) reset champs UI + statuts
  if(fileDico) fileDico.value = '';
  if(fileTrad) fileTrad.value = '';
  if(fileParents) fileParents.value = '';
  if(file404) file404.value = '';
  if(file200) file200.value = '';

  if(dicoStatus) dicoStatus.textContent = '';
  if(tradStatus) tradStatus.textContent = '';
  if(parentsStatus) parentsStatus.textContent = '';
  if(f404Status) f404Status.textContent = '';
  if(f200Status) f200Status.textContent = '';

  if(inpStop) inpStop.value = '';
  if(inpExc) inpExc.value = '';
  if(inpMulti) inpMulti.value = '';
  if(inpRegex) inpRegex.value = state.cfg.ref;
  if(inpMin) inpMin.value = String(state.cfg.min);

  if(inpSemanticWeight) inpSemanticWeight.value = '80';
  if(inpTokenBonus) inpTokenBonus.value = '5';
  if(inpTokenMalus) inpTokenMalus.value = '-10';

  // reset UI matching / progress / download
  resetDownloadUI();
  clearRunStatus();
  closeRunSummaryModal();
  stopFakeProgress();
  stopElapsedTimer();
  uiProgressHide();

  // rerender dicos + badge filtrage
  renderDicoTable();
  updatePrefilterBadge();

  // retourner sur un panel clean
  openPanel('config');
}

/* ✅ Logout "secure" sans faux timeout :
   - purge locale immédiate (scope: 'local') => UI reset instant
   - logout global en best-effort (ne bloque pas l'UI)
*/
elLogout.addEventListener('click', async () => {
  setLogoutPending(true);

  // UI immédiate
  closeGate();
  setGateMsg('');
  elUser.textContent = 'Déconnexion…';

  // On garde le token AVANT de purger la session locale
  let accessToken = null;
  try {
    const { data } = await supabaseClient.auth.getSession();
    accessToken = data?.session?.access_token || null;
  } catch {}

  // 1) Déconnexion locale immédiate (fiable, pas de réseau)
  try {
    await supabaseClient.auth.signOut({ scope: 'local' });
  } catch {}

  // 2) Tu veux "comme un refresh" => on vide aussi tes paramètres UI
  hardResetUIAndLocal();

  // 3) Logout global en best-effort (ne bloque pas)
  if (accessToken) {
    const ctrl = new AbortController();
    setTimeout(() => ctrl.abort(), 6000);

    fetch(`${window.SUPABASE_URL}/auth/v1/logout?scope=global`, {
      method: 'POST',
      headers: {
        apikey: window.SUPABASE_PUBLISHABLE_KEY,
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json;charset=UTF-8'
      },
      signal: ctrl.signal
    }).catch(() => {
      // best-effort : si ça échoue, l'utilisateur est déjà déconnecté localement
    });
  }

  // 4) UI finale + refresh page (optionnel mais cohérent avec ton besoin)
  setLogoutPending(false);
  elUser.textContent = '';
  elLogout.classList.add('hidden');
  elLoginOpen.classList.remove('hidden');
  elHistoryTop.classList.add('hidden');

  // Re-route et recharge
  route(null).catch(() => {});
  CURRENT_USER_ID = null;
  location.reload();
});

/* =================== Fin Auth =================== */


/* =================== Tabs & Panels =================== */
const tabs = document.querySelectorAll('.tab');
const panels = {
  config: document.getElementById('panel-config'),
  test: document.getElementById('panel-test'),
  matching: document.getElementById('panel-matching'),
  history: document.getElementById('panel-history')
};

function openPanel(name){
  Object.values(panels).forEach(p=>p.classList.remove('active'));
  if(panels[name]) panels[name].classList.add('active');

  tabs.forEach(x=>x.classList.remove('active'));
  const btn = document.querySelector(`.tab[data-tab="${name}"]`);
  if(btn) btn.classList.add('active');

  if(name === 'history') loadHistory().catch(()=>{});
}

tabs.forEach(t=> t.addEventListener('click',()=>openPanel(t.dataset.tab)));

elHistoryTop?.addEventListener('click', async ()=>{
  const session = await requireAuthOrGate('Connecte-toi pour accéder à ton historique.');
  if(!session) return;
  openPanel('history');
});


/* =================== Modal helpers =================== */
const modal = document.getElementById('modal');
const mTitle = document.getElementById('mTitle');
const mSubtitle = document.getElementById('mSubtitle');
const mBody = document.getElementById('mBody');
const mFoot = document.getElementById('mFoot');
const mClose = document.getElementById('mClose');
const mBackdrop = document.getElementById('mBackdrop');

function closeModal(){ modal?.classList.add('hidden'); }
mClose?.addEventListener('click', closeModal);
mBackdrop?.addEventListener('click', closeModal);

function showAlert({ title='Attention', subtitle='', html='' }){
  if(!modal) return alert(title);
  mTitle.textContent = title;
  mSubtitle.textContent = subtitle || '';
  mBody.innerHTML = html || '';
  mFoot.innerHTML = `<button class="btn primary" type="button" id="mOk">OK</button>`;
  modal.classList.remove('hidden');
  document.getElementById('mOk')?.addEventListener('click', closeModal);
}

function showConfirm({ title='Confirmer', subtitle='', html='', confirmText='Confirmer', danger=false }){
  return new Promise((resolve)=>{
    mTitle.textContent = title;
    mSubtitle.textContent = subtitle || '';
    mBody.innerHTML = html || '';
    mFoot.innerHTML = `
      <button class="btn ghost" type="button" id="mCancel">Annuler</button>
      <button class="btn ${danger?'danger':'primary'}" type="button" id="mConfirm">${confirmText}</button>
    `;
    modal.classList.remove('hidden');

    const done = (v)=>{ closeModal(); resolve(v); };
    document.getElementById('mCancel')?.addEventListener('click', ()=>done(false), { once:true });
    document.getElementById('mConfirm')?.addEventListener('click', ()=>done(true), { once:true });
  });
}

function escapeHtml(s){
  return String(s ?? '')
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'",'&#039;');
}

function showPrompt({ title='Nom du run', subtitle='Optionnel', placeholder='Ex: Décembre - redirections', defaultValue='' }){
  return new Promise((resolve)=>{
    mTitle.textContent = title;
    mSubtitle.textContent = subtitle || '';
    mBody.innerHTML = `
      <div style="display:grid;gap:10px">
        <div class="help">Tu peux laisser vide et renommer plus tard dans l’historique.</div>
        <input id="mInput" type="text" placeholder="${escapeHtml(placeholder)}" value="${escapeHtml(defaultValue)}">
      </div>
    `;
    mFoot.innerHTML = `
      <button class="btn ghost" type="button" id="mSkip">Ignorer</button>
      <button class="btn primary" type="button" id="mSave">Enregistrer</button>
    `;
    modal.classList.remove('hidden');

    const input = ()=> document.getElementById('mInput')?.value?.trim() || '';
    const done = (v)=>{ closeModal(); resolve(v); };

    document.getElementById('mSkip')?.addEventListener('click', ()=>done(null), { once:true });
    document.getElementById('mSave')?.addEventListener('click', ()=>done(input()), { once:true });
  });
}


/* =================== App state =================== */
const state={
  dicos:{},
  dicoWeights:{},
  translations:{},
  parents:[],
  cfg:{
    stop:new Set(),
    exc:new Set(),
    multi:[],
    ref:'(?i)ref[:\\- ]?([a-z0-9\\-]+)',
    min:0.5,
    semanticWeight: 80,
    tokenBonus: 5,
    tokenMalus: -10
  }
};

let CURRENT_USER_ID = null;

function getSettingsKey(userId){
  return `matcherFront::${userId || 'anon'}`;
}

function resetStateOnly(){
  state.dicos = {};
  state.dicoWeights = {};
  state.translations = {};
  state.parents = [];
  state.cfg = {
    stop: new Set(),
    exc: new Set(),
    multi: [],
    ref: '(?i)ref[:\\- ]?([a-z0-9\\-]+)',
    min: 0.5,
    semanticWeight: 80,
    tokenBonus: 5,
    tokenMalus: -10
  };
}

function serializeDicos(){
  const out = {};
  for (const [name, dict] of Object.entries(state.dicos || {})) {
    out[name] = {};
    for (const [k, synSet] of Object.entries(dict || {})) {
      out[name][k] = Array.from(synSet || []);
    }
  }
  return out;
}

function deserializeDicos(raw){
  const out = {};
  for (const [name, dict] of Object.entries(raw || {})) {
    out[name] = {};
    for (const [k, arr] of Object.entries(dict || {})) {
      out[name][k] = new Set(Array.isArray(arr) ? arr : []);
    }
  }
  return out;
}


function saveLocal(){
  const key = getSettingsKey(CURRENT_USER_ID);

  localStorage.setItem(key, JSON.stringify({
    dicos: serializeDicos(), // ✅ AJOUT ICI

    dicoWeights: state.dicoWeights,
    cfg: {
      stop: [...state.cfg.stop],
      exc: [...state.cfg.exc],
      multi: state.cfg.multi,
      ref: state.cfg.ref,
      min: state.cfg.min,
      semanticWeight: state.cfg.semanticWeight,
      tokenBonus: state.cfg.tokenBonus,
      tokenMalus: state.cfg.tokenMalus
    },
    translations: state.translations,
    parents: state.parents
  }));
}

function loadLocalForUser(userId){
  // reset pour éviter “mélange” entre comptes
  resetStateOnly();

  const key = getSettingsKey(userId);
  const raw = localStorage.getItem(key);

  // migration (si tu avais déjà des réglages dans l'ancienne clé)
  const legacy = localStorage.getItem('matcherFront');

  const src = raw || legacy;
  if(!src) return;

  try{
    const obj = JSON.parse(src);

    state.dicos = deserializeDicos(obj.dicos || {}); // ✅ AJOUT ICI

    state.dicoWeights = obj.dicoWeights || {};
    state.cfg.stop = new Set(obj?.cfg?.stop || []);
    state.cfg.exc = new Set(obj?.cfg?.exc || []);
    state.cfg.multi = obj?.cfg?.multi || [];
    state.cfg.ref = obj?.cfg?.ref || state.cfg.ref;
    state.cfg.min = obj?.cfg?.min ?? 0.5;

    state.cfg.semanticWeight = Number(obj?.cfg?.semanticWeight ?? 80);
    state.cfg.tokenBonus = Number(obj?.cfg?.tokenBonus ?? 5);
    state.cfg.tokenMalus = Number(obj?.cfg?.tokenMalus ?? -10);

    state.translations = obj.translations || {};
    state.parents = obj.parents || [];

    // si on a migré depuis l'ancienne clé, on la copie vers la clé user
    if(!raw && legacy){
      localStorage.setItem(key, src);
      // optionnel : supprimer l’ancienne clé globale
      // localStorage.removeItem('matcherFront');
    }
  }catch{}
}


/* =================== DOM refs =================== */
const fileDico=document.getElementById('fileDico');
const fileTrad=document.getElementById('fileTrad');
const fileParents=document.getElementById('fileParents');

const dicoStatus=document.getElementById('dicoStatus');
const tradStatus=document.getElementById('tradStatus');
const parentsStatus=document.getElementById('parentsStatus');

const inpStop=document.getElementById('inpStop');
const inpExc=document.getElementById('inpExc');
const inpMulti=document.getElementById('inpMulti');
const inpRegex=document.getElementById('inpRegex');
const inpMin=document.getElementById('inpMin');

const inpSemanticWeight=document.getElementById('inpSemanticWeight');
const inpTokenBonus=document.getElementById('inpTokenBonus');
const inpTokenMalus=document.getElementById('inpTokenMalus');

const btnApply=document.getElementById('btnApply');
const cfgStatus=document.getElementById('cfgStatus');

const testUrl=document.getElementById('testUrl');
const btnTest=document.getElementById('btnTest');
const testOut=document.getElementById('testOut');

const file404=document.getElementById('file404');
const file200=document.getElementById('file200');
const f404Status=document.getElementById('f404Status');
const f200Status=document.getElementById('f200Status');

const btnRun=document.getElementById('btnRun');
const btnClear=document.getElementById('btnClear');
const runStatus=document.getElementById('runStatus');

const tblDico=document.querySelector('#tblDico tbody');
const prefilterBadge=document.getElementById('prefilterBadge');

const downloadWrap = document.getElementById('downloadWrap');
const btnDownload = document.getElementById('btnDownload');
const downloadLabel = document.getElementById('downloadLabel');

function hydrateUIFromState(){
  // Inputs config
  if(inpStop) inpStop.value = [...state.cfg.stop].join(', ');
  if(inpExc) inpExc.value = [...state.cfg.exc].join(', ');
  if(inpMulti) inpMulti.value = state.cfg.multi.join(', ');
  if(inpRegex) inpRegex.value = state.cfg.ref;
  if(inpMin) inpMin.value = String(state.cfg.min);

  if(inpSemanticWeight) inpSemanticWeight.value = String(state.cfg.semanticWeight ?? 80);
  if(inpTokenBonus) inpTokenBonus.value = String(state.cfg.tokenBonus ?? 5);
  if(inpTokenMalus) inpTokenMalus.value = String(state.cfg.tokenMalus ?? -10);

  // Status text
  if(tradStatus) tradStatus.textContent = Object.keys(state.translations||{}).length ? `${Object.keys(state.translations).length} traduction(s).` : '';
  if(parentsStatus) parentsStatus.textContent = (state.parents||[]).length ? `${state.parents.length} URL(s) parent.` : '';

  // Table dicos (si tu n’as pas rechargé le fichier dico, state.dicos restera vide — c'est normal)
  renderDicoTable();
  updatePrefilterBadge();
}

/* Progress DOM */
const progressWrap = document.getElementById('progressWrap');
const progressLabel = document.getElementById('progressLabel');
const progressPct = document.getElementById('progressPct');
const progressBar = document.getElementById('progressBar');
const elapsedTxt = document.getElementById('elapsedTxt');
const etaTxt = document.getElementById('etaTxt');

let resultBlobUrl = null;
let resultFilename = 'result.csv';

function setRunStatus(kind, text){
  if(!runStatus) return;
  runStatus.classList.remove('hidden');
  runStatus.className = 'badge ' + (kind || 'info');
  runStatus.textContent = text || '';
}
function clearRunStatus(){
  runStatus?.classList.add('hidden');
  runStatus.textContent = '';
}

function resetDownloadUI() {
  if (resultBlobUrl) {
    URL.revokeObjectURL(resultBlobUrl);
    resultBlobUrl = null;
  }
  resultFilename = 'result.csv';
  downloadWrap.classList.add('hidden');
  downloadLabel.textContent = '';
}

btnDownload.addEventListener('click', () => {
  if (!resultBlobUrl) return;
  const a = document.createElement('a');
  a.href = resultBlobUrl;
  a.download = resultFilename || 'result.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
});

/* =================== Force re-import same file (reset on click) =================== */
function enableFileReimport(inputEl){
  if(!inputEl) return;
  inputEl.addEventListener('click', ()=>{ inputEl.value=''; });
}
enableFileReimport(fileDico);
enableFileReimport(fileTrad);
enableFileReimport(fileParents);
enableFileReimport(file404);
enableFileReimport(file200);

/* =================== Progress (fake + elapsed + ETA) =================== */
let progressTimer = null;
let fakeProgressTimer = null;
let runStartTs = 0;

function fmtSeconds(totalSec){
  const s = Math.max(0, Math.floor(totalSec));
  if(s < 60) return `${s}s`;
  const m = Math.floor(s / 60);
  const r = s % 60;
  return `${m}m ${r}s`;
}

function loadAvgRunSeconds(){
  try{
    const raw = localStorage.getItem('matcherAvgRunSeconds');
    const n = Number(raw);
    return Number.isFinite(n) && n > 0 ? n : null;
  }catch{ return null; }
}
function saveRunSeconds(seconds){
  const sec = Number(seconds);
  if(!Number.isFinite(sec) || sec <= 0) return;

  const old = loadAvgRunSeconds();
  const next = old == null ? sec : (old * 0.7 + sec * 0.3);
  try{ localStorage.setItem('matcherAvgRunSeconds', String(next)); }catch{}
}

function uiProgressShow(){
  if(!progressWrap) return;
  progressWrap.classList.remove('hidden');
  if(progressLabel) progressLabel.textContent = 'Traitement…';
  if(progressPct){ progressPct.className = 'badge info'; progressPct.textContent = '0%'; }
  if(progressBar) progressBar.style.width = '0%';
  if(elapsedTxt) elapsedTxt.textContent = '0s';
  if(etaTxt) etaTxt.textContent = '—';
}

function uiProgressHide(){
  if(!progressWrap) return;
  progressWrap.classList.add('hidden');
  if(progressBar) progressBar.style.width = '0%';
  if(progressPct) progressPct.textContent = '0%';
  if(elapsedTxt) elapsedTxt.textContent = '0s';
  if(etaTxt) etaTxt.textContent = '—';
}

function setProgress(p){
  const pct = Math.max(0, Math.min(100, Math.floor(p)));
  if(progressBar) progressBar.style.width = pct + '%';
  if(progressPct) progressPct.textContent = pct + '%';
}

function startElapsedTimer(){
  runStartTs = Date.now();
  const avg = loadAvgRunSeconds();

  stopElapsedTimer();
  progressTimer = setInterval(()=>{
    const elapsedSec = (Date.now() - runStartTs) / 1000;
    if(elapsedTxt) elapsedTxt.textContent = fmtSeconds(elapsedSec);

    if(avg != null){
      const remaining = Math.max(0, avg - elapsedSec);
      etaTxt.textContent = fmtSeconds(remaining);
    } else {
      etaTxt.textContent = 'calcul…';
    }
  }, 250);
}

function stopElapsedTimer(){
  if(progressTimer){ clearInterval(progressTimer); progressTimer = null; }
}

function startFakeProgress(){
  stopFakeProgress();
  let p = 0;
  setProgress(0);

  fakeProgressTimer = setInterval(()=>{
    if(p < 70) p += 2 + Math.random() * 2;
    else if(p < 88) p += 0.6 + Math.random() * 0.8;
    else if(p < 90) p += 0.2 + Math.random() * 0.3;
    else p = 90;

    setProgress(p);
  }, 250);
}

function stopFakeProgress(){
  if(fakeProgressTimer){ clearInterval(fakeProgressTimer); fakeProgressTimer = null; }
}

function finishProgressOK(){
  stopFakeProgress();
  setProgress(100);
  if(progressPct){ progressPct.className = 'badge ok'; progressPct.textContent = '100%'; }
  if(progressLabel) progressLabel.textContent = 'Terminé';
}

function finishProgressError(){
  stopFakeProgress();
  if(progressPct){ progressPct.className = 'badge err'; progressPct.textContent = 'Erreur'; }
  if(progressLabel) progressLabel.textContent = 'Erreur';
}

/* =================== Init inputs =================== */
inpStop.value=[...state.cfg.stop].join(', ');
inpExc.value=[...state.cfg.exc].join(', ');
inpMulti.value=state.cfg.multi.join(', ');
inpRegex.value=state.cfg.ref;
inpMin.value=state.cfg.min;

inpSemanticWeight.value = String(state.cfg.semanticWeight ?? 80);
inpTokenBonus.value = String(state.cfg.tokenBonus ?? 5);
inpTokenMalus.value = String(state.cfg.tokenMalus ?? -10);

btnApply.addEventListener('click',()=>{
  state.cfg.stop=new Set(inpStop.value.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean));
  state.cfg.exc=new Set(inpExc.value.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean));
  state.cfg.multi=inpMulti.value.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
  state.cfg.ref=inpRegex.value.trim()||state.cfg.ref;
  state.cfg.min=Number(inpMin.value)||0.5;

  state.cfg.semanticWeight = Number(inpSemanticWeight.value);
  if(!Number.isFinite(state.cfg.semanticWeight)) state.cfg.semanticWeight = 80;

  state.cfg.tokenBonus = Number(inpTokenBonus.value);
  if(!Number.isFinite(state.cfg.tokenBonus)) state.cfg.tokenBonus = 5;

  state.cfg.tokenMalus = Number(inpTokenMalus.value);
  if(!Number.isFinite(state.cfg.tokenMalus)) state.cfg.tokenMalus = -10;

  saveLocal();

  cfgStatus.classList.remove('hidden');
  cfgStatus.className = 'badge ok';
  cfgStatus.textContent = 'Paramètres enregistrés';
  setTimeout(()=>cfgStatus.classList.add('hidden'), 1600);
});


/* =================== URL builder (Cloud Run direct) =================== */
const PROD_API_BASE = "https://url-matcher-70649262164.europe-west1.run.app";
const DEV_API_BASE  = "https://url-matcher-70649262164.europe-west1.run.app";

function isLocalHost(){
  const h = location.hostname;
  return h === 'localhost' || h === '127.0.0.1';
}
function buildUrl(path){
  const p = path.startsWith('/') ? path : '/' + path;
  const base = isLocalHost() ? DEV_API_BASE : PROD_API_BASE;
  return base.replace(/\/$/, '') + p;
}


/* =================== Excel helpers + validation =================== */
async function readExcel(file){
  return new Promise((resolve,reject)=>{
    const reader=new FileReader();
    reader.onload=e=>{
      try{ const wb=XLSX.read(new Uint8Array(e.target.result),{type:'array'}); resolve(wb); }
      catch(err){ reject(err); }
    };
    reader.onerror=reject;
    reader.readAsArrayBuffer(file);
  });
}

function findSheet(wb, wanted){
  if(!wb) return null;
  const exact = wb.Sheets[wanted];
  if(exact) return exact;
  const sname = wb.SheetNames.find(n => String(n).trim().toLowerCase() === String(wanted).trim().toLowerCase());
  return sname ? wb.Sheets[sname] : null;
}

function sheetColumnsAsSet(sheet){
  const rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });
  if(!rows.length) return new Set();
  return new Set(Object.keys(rows[0] || {}).map(k=>String(k).trim()));
}

function assertColumns({ sheet, required, context }){
  const cols = sheetColumnsAsSet(sheet);
  const missing = required.filter(r => !cols.has(r));
  if(missing.length){
    showAlert({
      title: 'Fichier invalide',
      subtitle: context || '',
      html: `
        <div>Colonnes manquantes :</div>
        <ul>
          ${missing.map(m=>`<li><b>${escapeHtml(m)}</b></li>`).join('')}
        </ul>
        <div class="help">Vérifie l’en-tête (ligne 1) et le nom des colonnes.</div>
      `
    });
    return false;
  }
  return true;
}

async function validate404File(file){
  const wb = await readExcel(file);
  const sh = findSheet(wb, '404');
  if(!sh){
    showAlert({
      title:'Fichier des URLs à corriger invalide',
      subtitle:'Il faut un onglet nommé “404”.',
      html:`<div class="help">Ton fichier doit contenir un onglet <b>404</b> avec une colonne <b>URL_404</b>.</div>`
    });
    return false;
  }
  return assertColumns({ sheet: sh, required:['URL_404'], context:'URLs à corriger → colonne URL_404' });
}

async function validate200File(file){
  const wb = await readExcel(file);
  const sh = findSheet(wb, '200');
  if(!sh){
    showAlert({
      title:'Fichier des URLs valides invalide',
      subtitle:'Il faut un onglet nommé “200”.',
      html:`<div class="help">Ton fichier doit contenir un onglet <b>200</b> avec une colonne <b>URL_200</b>.</div>`
    });
    return false;
  }
  return assertColumns({ sheet: sh, required:['URL_200'], context:'URLs valides → colonne URL_200' });
}

async function validateTradFile(file){
  const wb = await readExcel(file);
  for(const name of wb.SheetNames){
    const sh = wb.Sheets[name];
    const cols = sheetColumnsAsSet(sh);
    if(cols.has('SOURCE') && cols.has('TRANSLATION')) return true;
  }
  showAlert({
    title:'Traductions invalides',
    subtitle:'Colonnes attendues : SOURCE, TRANSLATION',
    html:`<div class="help">Dans au moins un onglet, il faut les colonnes <b>SOURCE</b> et <b>TRANSLATION</b>.</div>`
  });
  return false;
}

async function validateParentsFile(file){
  const wb = await readExcel(file);
  for(const name of wb.SheetNames){
    const sh = wb.Sheets[name];
    const cols = sheetColumnsAsSet(sh);
    if(cols.has('URL')) return true;
  }
  showAlert({
    title:'Parents invalides',
    subtitle:'Colonne attendue : URL',
    html:`<div class="help">Dans au moins un onglet, il faut une colonne <b>URL</b>.</div>`
  });
  return false;
}

async function validateDicoFile(file){
  const wb = await readExcel(file);
  let totalHeaders = 0;
  for(const name of wb.SheetNames){
    const sh = wb.Sheets[name];
    const grid = XLSX.utils.sheet_to_json(sh, { header:1, blankrows:false });
    const headers = (grid?.[0] || []).map(x=>String(x||'').trim()).filter(Boolean);
    totalHeaders += headers.length;
  }
  if(totalHeaders <= 0){
    showAlert({
      title:'Listes de mots invalides',
      subtitle:'En-têtes vides',
      html:`<div class="help">La première ligne doit contenir les noms des listes (colonnes).</div>`
    });
    return false;
  }
  return true;
}


/* =================== Config build for API =================== */
function buildConfigFromUI(){
  const dictionaries = Object.entries(state.dicos).map(([name, dict]) => ({
    name,
    rows: Object.entries(dict).map(([k, synSet]) => [k, ...Array.from(synSet)].join(','))
  }));

  const bonus = {}, malus = {}, prefilter = {};
  Object.entries(state.dicoWeights || {}).forEach(([name, w]) => {
    bonus[name] = Number(w?.bonus || 0);
    malus[name] = Number(w?.malus || 0);
    prefilter[name] = !!w?.active;
  });

  return {
    stopwords: [...state.cfg.stop],
    exceptions: [...state.cfg.exc],
    multi: state.cfg.multi,
    refRegex: state.cfg.ref,
    translations: Object.entries(state.translations || {}).map(([SOURCE, TRANSLATION]) => ({ SOURCE, TRANSLATION })),
    dictionaries,
    bonus,
    malus,
    prefilter,
    scoreMin: state.cfg.min,
    parents: state.parents || [],
    embeddingWeight: state.cfg.semanticWeight,
    tokenBonusIdentical: state.cfg.tokenBonus,
    tokenPenaltyExtra: state.cfg.tokenMalus
  };
}


/* =================== Dico table rendering + badge =================== */
function updatePrefilterBadge(){
  const active = Object.keys(state.dicoWeights).filter(n => (state.dicoWeights[n] || {}).active);
  if(active.length>0){
    prefilterBadge.textContent='Filtrage : activé';
    prefilterBadge.className='badge ok';
    prefilterBadge.title='Au moins une liste utilisée : le filtrage automatique est appliqué.';
  } else {
    prefilterBadge.textContent='Filtrage : désactivé';
    prefilterBadge.className='badge info';
    prefilterBadge.title='Active une liste pour appliquer le filtrage automatique.';
  }
}

function renderDicoTable(){
  if(!tblDico) return;
  tblDico.innerHTML='';
  const names=Object.keys(state.dicos);
  if(names.length===0){
    const tr=document.createElement('tr'); const td=document.createElement('td');
    td.colSpan=5; td.textContent='Aucune liste chargée.'; td.style.color='var(--muted)'; td.style.fontWeight='800';
    tr.appendChild(td); tblDico.appendChild(tr);
    updatePrefilterBadge();
    return;
  }

  names.forEach(name=>{
    const dict=state.dicos[name];
    const w=state.dicoWeights[name]||{bonus:1,malus:1,active:true};
    const entries=Object.keys(dict).length;

    const tr=document.createElement('tr');
    tr.innerHTML=`
      <td style="font-weight:900">${escapeHtml(name)}</td>
      <td><input type="number" step="0.1" value="${w.bonus}" data-k="bonus" style="width:100%;padding:8px;border:1px solid var(--border);border-radius:12px;background:#fff"></td>
      <td><input type="number" step="0.1" value="${w.malus}" data-k="malus" style="width:100%;padding:8px;border:1px solid var(--border);border-radius:12px;background:#fff"></td>
      <td><input class="switch" type="checkbox" ${w.active?'checked':''} data-k="active"></td>
      <td>${entries.toLocaleString('fr-FR')}</td>
    `;
    tr.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('change',()=>{
        const key=inp.dataset.k;
        const row=state.dicoWeights[name]||{bonus:1,malus:1,active:true};
        if(key==='active') row.active=inp.checked;
        else row[key]=Number(inp.value);
        state.dicoWeights[name]=row;
        saveLocal();
        updatePrefilterBadge();
      });
    });
    tblDico.appendChild(tr);
  });

  updatePrefilterBadge();
}
renderDicoTable();


/* =================== File imports (validated with popups) =================== */
fileDico.addEventListener('change', async ()=>{
  if(!fileDico.files?.[0]) return;
  try{
    const ok = await validateDicoFile(fileDico.files[0]);
    if(!ok){ fileDico.value=''; dicoStatus.textContent=''; return; }

    const wb=await readExcel(fileDico.files[0]);
    state.dicos={};

    wb.SheetNames.forEach(sheetName=>{
      const sh=wb.Sheets[sheetName];
      const df=XLSX.utils.sheet_to_json(sh,{header:1,blankrows:false});
      if(!df.length) return;

      const cols=df[0].map((_,i)=>df.map(row=>row[i]));
      cols.forEach((col,idx)=>{
        const dicoName=String(df[0][idx]||`Dico_${idx+1}`).trim();
        if(!dicoName) return;

        if(!state.dicos[dicoName]) state.dicos[dicoName]={};

        for(let r=1;r<col.length;r++){
          const cell=col[r];
          if(cell==null) continue;
          const items=String(cell).split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
          if(!items.length) continue;
          const key=items[0];
          state.dicos[dicoName][key]=(state.dicos[dicoName][key]||new Set());
          items.forEach(x=>state.dicos[dicoName][key].add(x));
        }
      });
    });

    saveLocal();
    renderDicoTable();
    dicoStatus.textContent = `${Object.keys(state.dicos).length} liste(s) chargée(s).`;
  }catch(e){
    fileDico.value='';
    dicoStatus.textContent='';
    showAlert({ title:'Erreur', subtitle:'Lecture des listes de mots', html: escapeHtml(e?.message||String(e)) });
  }
});

fileTrad.addEventListener('change', async ()=>{
  if(!fileTrad.files?.[0]) return;
  try{
    const ok = await validateTradFile(fileTrad.files[0]);
    if(!ok){ fileTrad.value=''; tradStatus.textContent=''; return; }

    const wb=await readExcel(fileTrad.files[0]);
    state.translations={};

    wb.SheetNames.forEach(name=>{
      const sh=wb.Sheets[name];
      const arr=XLSX.utils.sheet_to_json(sh);
      arr.forEach(row=>{
        const s=String(row['SOURCE']||'').trim().toLowerCase();
        const t=String(row['TRANSLATION']||'').trim().toLowerCase();
        if(s) state.translations[s]=t;
      });
    });

    saveLocal();
    tradStatus.textContent = `${Object.keys(state.translations).length} traduction(s).`;
  }catch(e){
    fileTrad.value='';
    tradStatus.textContent='';
    showAlert({ title:'Erreur', subtitle:'Lecture des traductions', html: escapeHtml(e?.message||String(e)) });
  }
});

fileParents.addEventListener('change', async ()=>{
  if(!fileParents.files?.[0]) return;
  try{
    const ok = await validateParentsFile(fileParents.files[0]);
    if(!ok){ fileParents.value=''; parentsStatus.textContent=''; return; }

    const wb=await readExcel(fileParents.files[0]);
    state.parents=[];

    wb.SheetNames.forEach(name=>{
      const sh=wb.Sheets[name];
      const arr=XLSX.utils.sheet_to_json(sh);
      arr.forEach(row=>{
        if(row.URL) state.parents.push(String(row.URL));
      });
    });

    saveLocal();
    parentsStatus.textContent = `${state.parents.length} URL(s) parent.`;
  }catch(e){
    fileParents.value='';
    parentsStatus.textContent='';
    showAlert({ title:'Erreur', subtitle:'Lecture des parents', html: escapeHtml(e?.message||String(e)) });
  }
});

file404.addEventListener('change', async ()=>{
  if(!file404.files?.[0]) return;
  try{
    const ok = await validate404File(file404.files[0]);
    if(!ok){ file404.value=''; f404Status.textContent=''; return; }
    f404Status.textContent = `OK (${escapeHtml(file404.files[0].name)})`;
  }catch(e){
    file404.value='';
    f404Status.textContent='';
    showAlert({ title:'Erreur', subtitle:'Lecture du fichier des URLs à corriger', html: escapeHtml(e?.message||String(e)) });
  }
});

file200.addEventListener('change', async ()=>{
  if(!file200.files?.[0]) return;
  try{
    const ok = await validate200File(file200.files[0]);
    if(!ok){ file200.value=''; f200Status.textContent=''; return; }
    f200Status.textContent = `OK (${escapeHtml(file200.files[0].name)})`;
  }catch(e){
    file200.value='';
    f200Status.textContent='';
    showAlert({ title:'Erreur', subtitle:'Lecture du fichier des URLs valides', html: escapeHtml(e?.message||String(e)) });
  }
});


/* =================== Diagnostic URL =================== */
function formatDictHits(hits){
  if(!hits || typeof hits !== 'object') return null;

  const lines = [];
  Object.entries(hits).forEach(([dicoName, v])=>{
    if(v == null) return;
    if(Array.isArray(v)){
      if(v.length) lines.push(`Liste ${dicoName} : ${v.join(', ')}`);
    } else if(typeof v === 'string'){
      const s = v.trim();
      if(s) lines.push(`Liste ${dicoName} : ${s}`);
    } else if(typeof v === 'object'){
      const keys = Object.keys(v).filter(k => !!v[k]);
      if(keys.length) lines.push(`Liste ${dicoName} : ${keys.join(', ')}`);
    }
  });
  return lines.length ? lines : null;
}

btnTest.addEventListener('click', async () => {
  const url = testUrl.value.trim();
  if (!url) {
    testOut.value = 'Veuillez saisir une URL.';
    return;
  }

  try {
    const payload = { url, config: buildConfigFromUI() };

    const session = await getSessionSafe();
    const token = session?.access_token;
    if (!token) throw new Error("Tu dois être connecté(e) pour utiliser cette fonction.");

    const r = await fetch(buildUrl('/debug-url'), {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify(payload)
    });

    if (!r.ok) {
      throw new Error('Une erreur est survenue pendant le traitement. Réessaie dans quelques instants.');
    }

    const j = await r.json();

    const out = [];
    out.push(`URL saisie : ${j.input}`);
    out.push(`URL simplifiée : ${j.clean}`);
    out.push(`URL après remplacement des termes : ${j.substituted}`);
    out.push(`Mots détectés : ${j.tokens?.length ? j.tokens.join(', ') : 'Aucun'}`);
    out.push(j.reference ? `Référence détectée : ${j.reference}` : 'Aucune référence détectée.');

    const hits = j.dict_hits || j.dico_hits || j.characteristics || j.dictionaries || null;
    const lines = formatDictHits(hits);

    if (lines) {
      out.push('');
      out.push('Mots reconnus dans tes listes :');
      lines.forEach(x => out.push(' - ' + x));
    } else {
      out.push('');
      out.push('Mots reconnus dans tes listes : aucun mot détecté (ou information non disponible).');
    }

    testOut.value = out.join('\n');
  } catch (e) {
    testOut.value = 'Erreur : ' + (e?.message || String(e));
  }
});


/* =================== Run Summary Modal =================== */
const runSummaryModal = document.getElementById('runSummaryModal');
const runSummaryContent = document.getElementById('runSummaryContent');
const rsSubtitle = document.getElementById('rsSubtitle');
const btnRunSummaryClose = document.getElementById('btnRunSummaryClose');
const btnRunSummaryOk = document.getElementById('btnRunSummaryOk');
const btnRunSummaryDownload = document.getElementById('btnRunSummaryDownload');
const runSummaryBackdrop = document.getElementById('runSummaryBackdrop');

function openRunSummaryModal(){ runSummaryModal?.classList.remove('hidden'); }
function closeRunSummaryModal(){ runSummaryModal?.classList.add('hidden'); }
btnRunSummaryClose?.addEventListener('click', closeRunSummaryModal);
btnRunSummaryOk?.addEventListener('click', closeRunSummaryModal);
runSummaryBackdrop?.addEventListener('click', closeRunSummaryModal);

function toNumberSafe(v){
  const s = String(v ?? '')
    .replace('%', '')
    .replace(/\s+/g, '')
    .replace(',', '.');
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}

async function buildRunSummaryFromBlob(blob){
  const text = await blob.text();
  const wb = XLSX.read(text, { type: 'string', FS: ';' }); // ✅ ton CSV backend est en ';'
  const sh = wb.Sheets[wb.SheetNames[0]];
  const rows = XLSX.utils.sheet_to_json(sh, { defval: "" });

  const total = rows.length;
  const scoreKey = "Score_total_%"; // ✅ colonne réellement produite par le backend
  const url404Key = "URL_404";
  const url200Key = "URL_200_top1";

  const scored = rows
    .map((r) => ({
      score: toNumberSafe(r[scoreKey]),
      url404: String(r[url404Key] ?? ''),
      url200: String(r[url200Key] ?? '')
    }))
    .filter(x => Number.isFinite(x.score));

  scored.sort((a,b)=> b.score - a.score);

  const nScored = scored.length;
  const k = Math.max(1, Math.floor(nScored * 0.10));
  const startIndex = Math.max(0, nScored - k);
  const bottom = scored.slice(startIndex);

  const threshold = (nScored > 0) ? scored[startIndex]?.score : null;
  const startLineExcel = (startIndex + 1) + 1;
  const worst5 = bottom.slice().sort((a,b)=> a.score - b.score).slice(0, 5);

  return { total, nScored, k, threshold, startLineExcel, worst5 };
}

function renderRunSummary(summary){
  const { total, nScored, k, threshold, startLineExcel, worst5 } = summary;

  const thrTxt = (threshold == null) ? 'n/a' : `${Math.round(threshold)}%`;
  if(rsSubtitle) rsSubtitle.textContent = `Seuil de vérif (Score_total_% ≤ ${thrTxt}) · basé sur Score_total_%.`;



  const tableRows = worst5.map((x, idx) => {
    const s = Math.round(x.score);
    return `
      <tr>
        <td>${idx + 1}</td>
        <td><b>${s}%</b></td>
        <td class="rs-url">${escapeHtml(x.url404)}</td>
        <td class="rs-url">${escapeHtml(x.url200)}</td>
      </tr>
    `;
  }).join('');

  runSummaryContent.innerHTML = `
    <div class="rs-kpis">
      <div class="rs-kpi">
        <div class="label">URLs traitées</div>
        <div class="value">${Number(total).toLocaleString('fr-FR')}</div>
        <div class="hint">Total lignes (hors en-tête)</div>
      </div>
      <div class="rs-kpi">
        <div class="label">Scores exploitables</div>
        <div class="value">${Number(nScored).toLocaleString('fr-FR')}</div>
        <div class="hint">Basé sur “match_pct”</div>
      </div>
      <div class="rs-kpi">
        <div class="label">URLs à vérifier</div>
        <div class="value">${Number(k).toLocaleString('fr-FR')}</div>
        <div class="hint">Score ≤ ${thrTxt}</div>
      </div>
    </div>

    <div class="rs-callout">
      URLs à vérifier à partir de la ligne ${Number(startLineExcel).toLocaleString('fr-FR')}
      (dans Excel après tri décroissant de <b>Score_total_%</b>).


    </div>

    <div class="card" style="padding:0;border-radius:12px;box-shadow:none;border:1px solid var(--border)">
      <div style="padding:12px 12px 0 12px;font-weight:900">Top 5 à vérifier</div>
      <div style="padding:10px 12px 12px 12px;color:var(--muted);font-size:12px">
        Les plus faibles scores (échantillon pour contrôle rapide).
      </div>

      <div style="padding:0 12px 12px 12px">
        <table class="rs-table">
          <thead>
            <tr>
              <th style="width:55px">#</th>
              <th style="width:90px">Score</th>
              <th>URL à corriger</th>
              <th>URL proposée</th>
            </tr>
          </thead>
          <tbody>
            ${tableRows || `<tr><td colspan="4" style="color:var(--muted);padding:12px">Aucune donnée.</td></tr>`}
          </tbody>
        </table>
      </div>
    </div>
  `;
}

btnRunSummaryDownload?.addEventListener('click', () => {
  if (!resultBlobUrl) return;
  const a = document.createElement('a');
  a.href = resultBlobUrl;
  a.download = resultFilename || 'result.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
});


/* =================== Storage helpers (history) =================== */
const STORAGE_BUCKET = 'matcher-results';

function tsForRunId(){
  const iso = new Date().toISOString();
  return iso.slice(0,19).replace('T','_').replace(/:/g,'-');
}
function rand4(){ return Math.random().toString(16).slice(2,6); }
function makeRunId(){ return `${tsForRunId()}_${rand4()}`; }

function resultContentType(){
  return 'text/csv; charset=utf-8';
}

function extFromFile(file){
  const n = (file?.name || '').toLowerCase();
  if(n.endsWith('.xlsx')) return 'xlsx';
  if(n.endsWith('.xls')) return 'xls';
  return 'xlsx';
}
function prettyRunDate(runId){
  const parts = String(runId || '').split('_');
  if(parts.length < 2) return runId;
  const d = parts[0];
  const t = parts[1].replace(/-/g,':');
  return `${d} ${t}`;
}

async function storageSignedDownload(path, suggestedName){
  const { data, error } = await supabaseClient.storage
    .from(STORAGE_BUCKET)
    .createSignedUrl(path, 60);

  if(error) throw error;

  const a = document.createElement('a');
  a.href = data.signedUrl;
  a.download = suggestedName || path.split('/').pop();
  document.body.appendChild(a);
  a.click();
  a.remove();
}

async function uploadOne(path, fileOrBlob, contentType){
  const { error } = await supabaseClient.storage
    .from(STORAGE_BUCKET)
    .upload(path, fileOrBlob, { contentType: contentType || undefined, upsert: false });
  if(error) throw error;
}

async function overwriteJson(path, obj){
  try{
    await supabaseClient.storage.from(STORAGE_BUCKET).remove([path]);
  }catch{}
  const blob = new Blob([JSON.stringify(obj)], { type:'application/json' });
  await uploadOne(path, blob, 'application/json');
}

async function uploadRunFolder({ userId, runId, resultBlob, dicoFile, tradFile, parentsFile }){
  const base = `${userId}/runs/${runId}`;

  await uploadOne(`${base}/result.csv`, resultBlob, resultContentType());

  if(dicoFile){
    const ext = extFromFile(dicoFile);
    await uploadOne(
  `${base}/dico.${ext}`,
  dicoFile,
  dicoFile.type || (ext === 'xls'
    ? 'application/vnd.ms-excel'
    : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
);

  }
  if(tradFile){
    const ext = extFromFile(tradFile);
    await uploadOne(
  `${base}/trad.${ext}`,
  tradFile,
  tradFile.type || (ext === 'xls'
    ? 'application/vnd.ms-excel'
    : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
);

  }
  if(parentsFile){
    const ext = extFromFile(parentsFile);
    await uploadOne(
  `${base}/parents.${ext}`,
  parentsFile,
  parentsFile.type || (ext === 'xls'
    ? 'application/vnd.ms-excel'
    : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
);

  }

  await overwriteJson(`${base}/meta.json`, {
    name: '',
    created_at: new Date().toISOString()
  });

  return base;
}


/* =================== Historique =================== */
const tblHistory = document.getElementById('tblHistory');
const tblHistoryBody = tblHistory?.querySelector('tbody');
const historyStatus = document.getElementById('historyStatus');
const btnHistoryRefresh = document.getElementById('btnHistoryRefresh');

function renderHistoryEmpty(message){
  if(tblHistoryBody){
    tblHistoryBody.innerHTML = `
      <tr>
        <td colspan="5" style="color:var(--muted);font-weight:800">${escapeHtml(message || 'Aucun élément.')}</td>
      </tr>
    `;
  }
  if(historyStatus) historyStatus.textContent = '';
}

function badgeForFile(name){
  const n = String(name||'').toLowerCase();
  if(n.startsWith('result')) return `<span class="badge ok">result</span>`;
  if(n.startsWith('dico')) return `<span class="badge info">listes</span>`;
  if(n.startsWith('trad')) return `<span class="badge info">trad</span>`;
  if(n.startsWith('parents')) return `<span class="badge info">parents</span>`;
  if(n.startsWith('meta')) return `<span class="badge warn">meta</span>`;
  return `<span class="badge info">${escapeHtml(name)}</span>`;
}

function makeActionBtn(label, attrs = {}, kind='ghost'){
  const data = Object.entries(attrs).map(([k,v])=>`data-${k}="${encodeURIComponent(String(v))}"`).join(' ');
  return `<button class="btn ${kind} mini" type="button" ${data} style="margin-right:6px;margin-top:6px">${escapeHtml(label)}</button>`;
}

/* Dirty tracking for run names */
const dirtyRunName = new Set();
function markDirty(runId, isDirty){
  if(isDirty) dirtyRunName.add(runId);
  else dirtyRunName.delete(runId);

  const btn = tblHistoryBody?.querySelector(`button[data-action="saveName"][data-runid="${CSS.escape(runId)}"]`);
  if(btn) btn.classList.toggle('hidden', !dirtyRunName.has(runId));
}

async function loadHistory(){
  const session = await getSessionSafe();
  if(!session){
    renderHistoryEmpty('Connecte-toi pour voir ton historique.');
    return;
  }

  const userId = session.user.id;
  if(historyStatus) historyStatus.textContent = 'Chargement…';
  if(!tblHistoryBody) return;

  const { data: items, error } = await supabaseClient.storage
    .from(STORAGE_BUCKET)
    .list(`${userId}/runs`, { limit: 100, sortBy: { column: 'name', order: 'desc' } });

  if(error){
    renderHistoryEmpty('Impossible d’accéder à l’historique pour le moment. Réessaie plus tard.');
    if(historyStatus) historyStatus.textContent = '';
    return;
  }

  const folders = (items || []).filter(it => it?.id == null && it?.name);
  const runIds = folders.map(f=>f.name).filter(Boolean);

  if(!runIds.length){
    renderHistoryEmpty('Aucun run pour l’instant.');
    if(historyStatus) historyStatus.textContent = '';
    return;
  }

  async function listFilesInRun(runId){
    const { data, error } = await supabaseClient.storage
      .from(STORAGE_BUCKET)
      .list(`${userId}/runs/${runId}`, { limit: 60, sortBy: { column: 'name', order: 'asc' } });
    if(error) return { runId, files: [], metaName: '', error };
    const files = (data || []).filter(x => x?.id !== null);
    return { runId, files, metaName:'', error:null };
  }

  const maxConcurrent = 6;
  const listed = [];
  for(let i=0;i<runIds.length;i+=maxConcurrent){
    const chunk = runIds.slice(i, i+maxConcurrent);
    const res = await Promise.all(chunk.map(listFilesInRun));
    listed.push(...res);
  }

  async function fetchMetaName(basePath){
    const { data: signed, error } = await supabaseClient.storage.from(STORAGE_BUCKET).createSignedUrl(basePath, 60);
    if(error) return '';
    try{
      const r = await fetch(signed.signedUrl);
      if(!r.ok) return '';
      const j = await r.json();
      return String(j?.name || '').trim();
    }catch{
      return '';
    }
  }

  for(const r of listed){
    const meta = r.files.find(f => String(f.name||'').toLowerCase() === 'meta.json');
    if(meta){
      const path = `${userId}/runs/${r.runId}/meta.json`;
      r.metaName = await fetchMetaName(path);
    }
  }

  tblHistoryBody.innerHTML = '';
  listed.forEach(r=>{
    const runId = r.runId;
    const base = `${userId}/runs/${runId}`;
    const files = r.files || [];
    const fileNames = files.map(f => f.name);

    const filesBadges = fileNames.length
      ? fileNames.filter(n=>String(n).toLowerCase()!=='meta.json').map(badgeForFile).join(' ')
      : `<span class="badge err">vide</span>`;

    let actions = '';
    if(fileNames.some(n => n.toLowerCase().startsWith('result'))){
      actions += makeActionBtn('Télécharger résultat', { action:'download', path:`${base}/result.csv`, filename:'result.csv' });
    }

    const dico = fileNames.find(n => n.toLowerCase().startsWith('dico.'));
    const trad = fileNames.find(n => n.toLowerCase().startsWith('trad.'));
    const parents = fileNames.find(n => n.toLowerCase().startsWith('parents.'));

    if(dico) actions += makeActionBtn('Listes', { action:'download', path:`${base}/${dico}`, filename:dico });
    if(trad) actions += makeActionBtn('Trad', { action:'download', path:`${base}/${trad}`, filename:trad });
    if(parents) actions += makeActionBtn('Parents', { action:'download', path:`${base}/${parents}`, filename:parents });

    actions += makeActionBtn('Supprimer', { action:'deleteRun', runid: runId }, 'danger');

    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${escapeHtml(prettyRunDate(runId))}</td>
      <td>
        <input type="text"
          value="${escapeHtml(r.metaName || '')}"
          placeholder="Nom du run…"
          style="width:100%;background:#fff"
          data-action="nameInput"
          data-runid="${escapeHtml(runId)}"
          data-initial="${escapeHtml(r.metaName || '')}"
        >
        <div style="margin-top:8px">
          ${makeActionBtn('Enregistrer', { action:'saveName', runid: runId }, 'ghost')}
        </div>
      </td>
      <td style="font-size:12px;color:var(--muted)">${escapeHtml(runId)}</td>
      <td>${filesBadges}</td>
      <td>${actions}</td>
    `;
    tblHistoryBody.appendChild(tr);

    markDirty(runId, false);
  });

  if(historyStatus) historyStatus.textContent = `Runs: ${listed.length}`;
}

btnHistoryRefresh?.addEventListener('click', ()=> loadHistory().catch(()=>{}));

tblHistoryBody?.addEventListener('input', (e)=>{
  const input = e.target.closest('input[data-action="nameInput"]');
  if(!input) return;
  const runId = String(input.getAttribute('data-runid') || '');
  const initial = String(input.getAttribute('data-initial') || '');
  const current = String(input.value || '');
  markDirty(runId, current.trim() !== initial.trim());
});

tblHistoryBody?.addEventListener('click', async (e)=>{
  const btn = e.target.closest('button');
  if(!btn) return;

  const action = decodeURIComponent(btn.getAttribute('data-action') || '');
  const runId = decodeURIComponent(btn.getAttribute('data-runid') || '');

  const session = await requireAuthOrGate('Connecte-toi pour accéder à ton historique.');
  if(!session) return;

  const userId = session.user.id;
  const base = `${userId}/runs/${runId}`;

  if(action === 'download'){
    const path = decodeURIComponent(btn.getAttribute('data-path') || '');
    const fname = decodeURIComponent(btn.getAttribute('data-filename') || '') || path.split('/').pop();
    try{
      await storageSignedDownload(path, fname);
    }catch(err){
      showAlert({ title:'Téléchargement impossible', subtitle:'Historique', html: escapeHtml(err?.message || String(err)) });
    }
  }

  if(action === 'saveName'){
    const input = tblHistoryBody.querySelector(`input[data-action="nameInput"][data-runid="${CSS.escape(runId)}"]`);
    const name = (input?.value || '').trim();
    try{
      await overwriteJson(`${base}/meta.json`, { name, updated_at: new Date().toISOString() });
      if(input){
        input.setAttribute('data-initial', name);
      }
      markDirty(runId, false);
      showAlert({ title:'OK', subtitle:'Nom enregistré', html:`<div>Le run a été renommé.</div>` });
      loadHistory().catch(()=>{});
    }catch(err){
      showAlert({ title:'Erreur', subtitle:'Impossible d’enregistrer le nom', html: escapeHtml(err?.message || String(err)) });
    }
  }

  if(action === 'deleteRun'){
    const yes = await showConfirm({
      title: 'Supprimer ce run ?',
      subtitle: 'Cette action est définitive.',
      html: `<div>Run : <b>${escapeHtml(runId)}</b></div><div class="help" style="margin-top:8px">Le résultat + les fichiers (listes/trad/parents) seront supprimés.</div>`,
      confirmText: 'Supprimer',
      danger: true
    });
    if(!yes) return;

    try{
      const { data, error } = await supabaseClient.storage
        .from(STORAGE_BUCKET)
        .list(`${base}`, { limit: 100, sortBy: { column: 'name', order: 'asc' } });

      if(error) throw error;
      const files = (data || []).filter(x => x?.id !== null).map(x => `${base}/${x.name}`);
      if(files.length){
        const { error: rmErr } = await supabaseClient.storage.from(STORAGE_BUCKET).remove(files);
        if(rmErr) throw rmErr;
      }
      showAlert({ title:'Supprimé', subtitle:'Run supprimé', html:`<div>Le run a été supprimé.</div>` });
      loadHistory().catch(()=>{});
    }catch(err){
      showAlert({ title:'Erreur', subtitle:'Suppression impossible', html: escapeHtml(err?.message || String(err)) });
    }
  }
});


/* =================== Matching =================== */
btnClear.addEventListener('click',()=>{
  file404.value='';
  file200.value='';
  f404Status.textContent='';
  f200Status.textContent='';
  resetDownloadUI();
  clearRunStatus();
  closeRunSummaryModal();

  stopFakeProgress();
  stopElapsedTimer();
  uiProgressHide();
});

btnRun.addEventListener('click', async () => {
  const session = await requireAuthOrGate('Connecte-toi pour lancer le traitement.');
  if(!session) return;

  resetDownloadUI();
  closeRunSummaryModal();
  clearRunStatus();

  if (!file404.files?.[0] || !file200.files?.[0]) {
    showAlert({ title:'Fichiers manquants', subtitle:'Traitement', html:'<div>Importe les <b>URLs à corriger</b> et les <b>URLs valides</b> avant de lancer.</div>' });
    return;
  }

  try{
    const ok404 = await validate404File(file404.files[0]);
    if(!ok404) { file404.value=''; f404Status.textContent=''; return; }
    const ok200 = await validate200File(file200.files[0]);
    if(!ok200) { file200.value=''; f200Status.textContent=''; return; }
  }catch(e){
    showAlert({ title:'Erreur', subtitle:'Validation des fichiers', html: escapeHtml(e?.message||String(e)) });
    return;
  }

  btnRun.disabled = true;
  btnClear.disabled = true;

  const oldBtnText = btnRun.textContent;
  btnRun.textContent = 'Traitement…';
  setRunStatus('info', 'Traitement en cours…');

  uiProgressShow();
  startElapsedTimer();
  startFakeProgress();

  try{
    const form = new FormData();
    form.append('file404', file404.files[0]);
    form.append('file200', file200.files[0]);
    form.append('config', JSON.stringify(buildConfigFromUI()));

    const token = session?.access_token || null;
    const headers = {};
    if (token) headers['Authorization'] = `Bearer ${token}`;

    const r = await fetch(buildUrl('/match'), { method: 'POST', headers, body: form });
    if (!r.ok) throw new Error('Une erreur est survenue pendant le traitement. Réessaie dans quelques instants.');

    const blob = await r.blob();

    const elapsedSec = (Date.now() - runStartTs) / 1000;
    saveRunSeconds(elapsedSec);
    finishProgressOK();

    resultBlobUrl = URL.createObjectURL(blob);
    resultFilename = 'result.csv';
    downloadWrap.classList.remove('hidden');
    downloadLabel.textContent = 'Résultat prêt';

    setRunStatus('info', 'Sauvegarde dans l’historique…');

    const runId = makeRunId();
    await uploadRunFolder({
      userId: session.user.id,
      runId,
      resultBlob: blob,
      dicoFile: fileDico?.files?.[0] || null,
      tradFile: fileTrad?.files?.[0] || null,
      parentsFile: fileParents?.files?.[0] || null
    });

    const pretty = prettyRunDate(runId);
    const name = await showPrompt({
      title:'Nom du run',
      subtitle:`Run: ${pretty}`,
      placeholder:'Ex: Décembre - site FR',
      defaultValue:''
    });

    if(name !== null){
      await overwriteJson(`${session.user.id}/runs/${runId}/meta.json`, { name, updated_at: new Date().toISOString() });
    }

    setRunStatus('ok', 'Terminé (run enregistré)');

    try{
      const summary = await buildRunSummaryFromBlob(blob);
      renderRunSummary(summary);
      openRunSummaryModal();
    }catch{}

  }catch(e){
    finishProgressError();
    clearRunStatus();
    setRunStatus('err', 'Erreur');
    showAlert({ title:'Erreur pendant le traitement', subtitle:'Traitement', html: escapeHtml(e?.message || String(e)) });
    resetDownloadUI();
  }finally{
    stopFakeProgress();
    stopElapsedTimer();
    btnRun.disabled = false;
    btnClear.disabled = false;
    btnRun.textContent = oldBtnText;
  }
});


/* =================== Misc (render initial status) =================== */
dicoStatus.textContent = Object.keys(state.dicos||{}).length ? `${Object.keys(state.dicos).length} liste(s) chargée(s).` : '';
tradStatus.textContent = Object.keys(state.translations||{}).length ? `${Object.keys(state.translations).length} traduction(s).` : '';
parentsStatus.textContent = (state.parents||[]).length ? `${state.parents.length} URL(s) parent.` : '';

/* ✅ BOOTSTRAP SAFE (à la fin, quand tout est déclaré) */
(async function boot(){
  const session = await getSessionSafe();

  // important: CURRENT_USER_ID et state existent maintenant
  CURRENT_USER_ID = session?.user?.id || null;

  loadLocalForUser(CURRENT_USER_ID);
  hydrateUIFromState();

  await applyAuthUI(session || null);
  await route(session || null);

  window.addEventListener('popstate', ()=> route().catch(()=>{}));
})();
</script>
</div> <!-- ferme appShell -->
</body>
</html>
