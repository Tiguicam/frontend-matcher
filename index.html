<!doctype html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Redirect Match</title>

  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --text:#0f172a;
      --muted:#64748b;
      --border:#e5e7eb;

      --accent:#2563eb;
      --accent-600:#1d4ed8;

      --ok:#16a34a;
      --warn:#f59e0b;
      --err:#dc2626;

      --shadow:0 10px 30px #0000000a;
    }

    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text)}
    a{color:var(--accent);text-decoration:none}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.95em}

    .container{max-width:1100px;margin:0 auto;padding:0 20px}

    /* Topbar */
    .topbar{
      position:sticky;top:0;z-index:40;
      background:rgba(255,255,255,.85);
      backdrop-filter:saturate(180%) blur(10px);
      border-bottom:1px solid var(--border)
    }
    .nav{display:flex;align-items:center;justify-content:space-between;height:60px}
    .brand{display:flex;align-items:center;gap:10px;font-weight:900;letter-spacing:.2px}
    .brand .logo{width:10px;height:24px;background:var(--accent);border-radius:4px}

    .actions{display:flex;align-items:center;gap:10px}
    .user{font-size:13px;color:var(--muted)}

    .btn{cursor:pointer;border:none;border-radius:10px;font-weight:800;padding:10px 14px}
    .btn.primary{background:var(--accent);color:#fff}
    .btn.primary:hover{background:var(--accent-600)}
    .btn.ghost{background:#fff;border:1px solid var(--border);color:var(--text)}
    .btn.ghost:hover{background:#fafafa}
    .btn.danger{background:#fff;border:1px solid #fecaca;color:#991b1b}
    .btn.danger:hover{background:#fff5f5}
    .btn.mini{padding:8px 10px;border-radius:10px;font-size:13px;font-weight:900}
    .hidden{display:none !important}

    /* Tabs */
    .tabs{display:flex;gap:8px;border-bottom:1px solid var(--border);padding:14px 0;margin:0 0 16px 0;flex-wrap:wrap}
    .tab{
      padding:8px 12px;border-radius:999px;background:#fff;color:var(--text);
      cursor:pointer;border:1px solid var(--border);font-weight:900;font-size:13px
    }
    .tab.active{background:var(--accent);color:#fff;border-color:var(--accent)}
    .tab-panel{display:none}
    .tab-panel.active{display:block}

    /* Layout / cards */
    .page{padding:18px 0 36px}
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      padding:16px;
      box-shadow:var(--shadow)
    }
    .section-title{font-weight:950;margin:0 0 10px 0;display:flex;align-items:center;gap:10px}
    .sub{margin-top:6px;color:var(--muted);line-height:1.45;font-size:13px}

    .row{display:flex;gap:12px;flex-wrap:wrap}
    .grow{flex:1 1 260px}

    input[type=text],input[type=url],input[type=number],input[type=email],input[type=password],textarea{
      width:100%;padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:#fafafa;color:var(--text)
    }
    input[type=file]{width:100%}
    textarea{resize:vertical}

    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px;font-weight:900}

    .badge{
      display:inline-block;padding:4px 10px;border-radius:999px;font-size:12px;
      border:1px solid var(--border);background:#fff;color:var(--muted);font-weight:900
    }
    .badge.ok{background:#dcfce7;color:#065f46;border-color:#bbf7d0}
    .badge.err{background:#fee2e2;color:#991b1b;border-color:#fecaca}
    .badge.info{background:#eff6ff;color:#1e3a8a;border-color:#bfdbfe}
    .badge.warn{background:#fffbeb;color:#92400e;border-color:#fde68a}

    .badge.nowrap{
  display:inline-flex;
  align-items:center;
  white-space:nowrap;
}

    .badge.mono{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
}

    .badge.ellipsis{
  max-width: 240px;
  overflow: hidden;
  text-overflow: ellipsis;
}

    
.label-row{
  display:flex;
  align-items:center;
  gap:8px;
}

.label-row label{
  margin:0;
  line-height:1.2;
}



.tip{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:20px;
  height:20px;
  border-radius:999px;
  border:1px solid var(--border);
  background:#fff;
  color:var(--muted);
  font-weight:950;
  font-size:12px;
  cursor:help;
  position:relative;
  user-select:none;
}

.tip:hover::after,
.tip:focus::after{
  content: attr(data-tip);
  position:absolute;
  right:0;
  top:28px;
  width:min(320px, 70vw);
  background:#0f172a;
  color:#fff;
  padding:10px 12px;
  border-radius:12px;
  font-size:12px;
  line-height:1.35;
  box-shadow:0 10px 30px #00000033;
  z-index:999;
}



    /* Tables */
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px;border-bottom:1px solid var(--border);text-align:left;vertical-align:top}
    th{font-size:12px;color:var(--muted);font-weight:950;background:#fafafa}
    td{font-size:13px}
    .table-wrap{overflow:auto;border:1px solid var(--border);border-radius:14px;background:#fff}

    .switch{appearance:none;width:42px;height:24px;background:#e5e7eb;border-radius:999px;position:relative;outline:none;cursor:pointer;transition:.2s}
    .switch:checked{background:var(--accent)}
    .switch:before{content:"";position:absolute;left:3px;top:3px;width:18px;height:18px;background:#fff;border-radius:999px;transition:.2s;box-shadow:0 1px 3px #0001}
    .switch:checked:before{left:21px}

    details{background:#fafafa;border:1px solid var(--border);border-radius:14px;padding:12px}
    summary{cursor:pointer;font-weight:950}
    .help{font-size:12px;color:var(--muted)}

    /* Progress bar */
    #progressBar{
      background: var(--accent);
      border-radius: 999px;
      transition: width .25s ease;
    }

    /* Blur background when gate is open */
    #appShell.blurred{
      filter: blur(6px);
      pointer-events: none;
      user-select: none;
    }

    /* Auth Gate */
    #gate{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(15,23,42,.25);z-index:80}
    #gate .card{width:min(520px, calc(100% - 24px));box-shadow:0 30px 80px #00000033}

    /* Modal (alerts + confirm + prompt) */
    #modal.hidden{display:none !important;}
    #modal{position:fixed;inset:0;z-index:90}
    .m-backdrop{position:absolute;inset:0;background:rgba(15,23,42,.45)}
    .m-box{
      position:relative;
      width:min(560px, calc(100% - 26px));
      margin:80px auto;
      background:#fff;border:1px solid var(--border);border-radius:16px;
      box-shadow:0 30px 80px #00000033;overflow:hidden
    }
    .m-head{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:flex-start;gap:12px}
    .m-title{font-weight:950}
    .m-body{padding:16px;color:var(--text);font-size:14px;line-height:1.5}
    .m-foot{padding:14px 16px;border-top:1px solid var(--border);display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap}

    /* Run Summary Modal */
    #runSummaryModal.hidden{display:none !important;}
    #runSummaryModal{position:fixed;inset:0;z-index:85;}
    .rs-backdrop{position:absolute;inset:0;background:rgba(15,23,42,.45);}

    #appShell.hidden { display:none !important; }

    /* IMPORTANT: scrollable modal */
    .rs-modal{
      position:relative;
      width:min(760px, calc(100% - 28px));
      margin:40px auto;
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow:0 30px 80px #00000033;
      overflow:hidden;

      display:flex;
      flex-direction:column;
      max-height: calc(100vh - 80px);
    }
    .rs-header{
      flex:0 0 auto;
      display:flex;align-items:flex-start;justify-content:space-between;gap:12px;
      padding:16px 16px;
      border-bottom:1px solid var(--border);
      background:rgba(255,255,255,.9);
    }
    .rs-title{font-weight:950;font-size:18px;margin:0;color:var(--text)}
    .rs-subtitle{margin-top:4px;color:var(--muted);font-size:13px;line-height:1.35}

    .rs-body{
      flex:1 1 auto;
      padding:16px;
      display:grid;
      gap:12px;
      overflow:auto;
    }

    .rs-kpis{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px;}
    @media (max-width:720px){
      .rs-kpis{grid-template-columns:1fr;}
      .rs-modal{ margin:16px auto; max-height: calc(100vh - 32px); }
    }
    .rs-kpi{border:1px solid var(--border);border-radius:12px;padding:12px;background:#fafafa;}
    .rs-kpi .label{font-size:12px;color:var(--muted);margin-bottom:6px;font-weight:950}
    .rs-kpi .value{font-size:20px;font-weight:950;color:var(--text);line-height:1}
    .rs-kpi .hint{margin-top:6px;font-size:12px;color:var(--muted)}
    .rs-callout{border:1px solid #bfdbfe;background:#eff6ff;color:#1e3a8a;border-radius:12px;padding:12px;font-size:13px;line-height:1.35;font-weight:900}
    .rs-table{width:100%;border-collapse:separate;border-spacing:0;border:1px solid var(--border);border-radius:12px;overflow:hidden;}
    .rs-table th,.rs-table td{padding:10px;border-bottom:1px solid var(--border);vertical-align:top;}
    .rs-table th{font-size:12px;color:var(--muted);font-weight:950;background:#fafafa;}
    .rs-table tr:last-child td{border-bottom:none;}
    .rs-url{word-break:break-word;color:var(--text);font-size:12px;line-height:1.35;}

    .rs-footer{
      flex:0 0 auto;
      display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;
      padding:14px 16px;border-top:1px solid var(--border);background:#fff;
    }

    /* Footer */
    .footer{margin:22px 0 0;color:var(--muted);font-size:12px}

    /* Logout mini loader */
    .spinner{
      width:14px;height:14px;
      border:2px solid #cbd5e1;
      border-top-color: var(--accent);
      border-radius:999px;
      display:inline-block;
      animation:spin .7s linear infinite;
      vertical-align:-2px;
      margin-right:8px;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    window.SUPABASE_URL="https://srvvdrhiaygklqjijdtq.supabase.co";
    window.SUPABASE_PUBLISHABLE_KEY="sb_publishable_Tm5K5o-Fq_UBHP9Qp6JBog_rtKQjpDi";
  </script>
</head>

<body>
  <!-- Topbar -->
  <div class="topbar">
    <div class="container nav">
      <div class="brand">
        <div class="logo"></div><span>Redirect Match</span>
      </div>

      <div class="actions">
        <span id="currentUser" class="user"></span>
        <button id="btnLoginOpen" class="btn primary">Se connecter</button>
        <button id="btnHistoryTop" class="btn ghost hidden">Historique</button>
        <button id="btnLogout" class="btn ghost hidden">Se déconnecter</button>
      </div>
    </div>
  </div>

  <!-- Auth Gate -->
  <div id="gate" class="hidden">
    <div class="card">
      <div class="section-title" style="font-size:18px;margin-bottom:6px">Connexion</div>
      <div class="sub">Connecte-toi pour lancer un matching et accéder à ton historique.</div>

      <div class="row" style="margin-top:12px">
        <div class="grow">
          <label>Email</label>
          <input id="authEmail" type="email" placeholder="you@domain.tld">
        </div>
        <div class="grow">
          <label>Mot de passe</label>
          <input id="authPassword" type="password" placeholder="••••••••">
        </div>
      </div>

      <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap">
        <button class="btn primary" id="btnLogin">Se connecter</button>
        <button class="btn ghost" id="btnSignup">Créer un compte</button>
        <button class="btn ghost" id="btnGateClose" type="button">Fermer</button>
      </div>

      <div id="authStatus" class="sub" style="margin-top:10px"></div>
    </div>
  </div>

  <!-- Generic Modal -->
  <div id="modal" class="hidden">
    <div class="m-backdrop" id="mBackdrop"></div>
    <div class="m-box" role="dialog" aria-modal="true">
      <div class="m-head">
        <div>
          <div class="m-title" id="mTitle">Info</div>
          <div class="sub" id="mSubtitle" style="margin-top:6px"></div>
        </div>
        <button class="btn ghost mini" id="mClose" type="button">Fermer</button>
      </div>
      <div class="m-body" id="mBody"></div>
      <div class="m-foot" id="mFoot"></div>
    </div>
  </div>

  <div id="appShell">
    <!-- Main -->
    <div class="container page">
      <div class="tabs">
        <button class="tab active" data-tab="config">Paramètres</button>
        <button class="tab" data-tab="test">Diagnostic URL</button>
        <button class="tab" data-tab="matching">Traitement</button>
      </div>

      <!-- Panel: Configuration -->
      <section id="panel-config" class="tab-panel active">
        <div class="card">
          <div class="section-title">
            Paramètres
            <span id="prefilterBadge" class="badge info" title="Le filtrage automatique est activé si au moins une liste de mots est cochée.">Filtrage : désactivé</span>
          </div>

<div class="row" style="margin-top:14px">
  <!-- Listes de mots -->
  <div class="grow">
    <div class="label-row">
      <label>Listes de mots (Excel)</label>
      <span
        class="tip"
        tabindex="0"
        data-tip="Importe un Excel où chaque colonne = une liste. Chaque cellule contient : clé, syn1, syn2... séparés par des virgules."
      >?</span>
    </div>

    <input id="fileDico" type="file" accept=".xlsx,.xls" />

    <div class="sub" style="margin-top:6px">
      <a href="/templates/listes_de_mots_template.xlsx" download>Télécharger le template</a>
    </div>

    <div id="dicoStatus" class="sub"></div>
  </div>

  <!-- Traductions -->
  <div class="grow">
    <div class="label-row">
      <label>Traductions Excel</label>
      <span
        class="tip"
        tabindex="0"
        data-tip="Importe un Excel avec au moins un onglet contenant les colonnes SOURCE et TRANSLATION. Une ligne = une traduction."
      >?</span>
    </div>

    <input id="fileTrad" type="file" accept=".xlsx,.xls" />

    <div class="sub" style="margin-top:6px">
      <a href="/templates/traductions_template.xlsx" download>Télécharger le template</a>
    </div>

    <div id="tradStatus" class="sub"></div>
  </div>
</div>

<!-- Parents : sur une ligne séparée -->
<div class="row" style="margin-top:10px">
  <div class="grow">
    <div class="label-row">
      <label>Parents (optionnel)</label>
      <span
        class="tip"
        tabindex="0"
        data-tip="Optionnel. Importe un Excel contenant une colonne URL (dans n’importe quel onglet). Chaque ligne = une URL parent."
      >?</span>
    </div>

    <input id="fileParents" type="file" accept=".xlsx,.xls" />

    <div class="sub" style="margin-top:6px">
      <a href="/templates/parents_template.xlsx" download>Télécharger le template</a>
    </div>

    <div id="parentsStatus" class="sub"></div>
  </div>
</div>

<details style="margin-top:14px" open>
  <summary>Réglages avancés</summary>

  <div class="row" style="margin-top:12px">
    <div class="grow">
      <div class="label-row">
        <label>Mots à ignorer</label>
        <span class="tip" tabindex="0" data-tip="Liste séparée par des virgules. Ces mots seront ignorés dans la comparaison.">?</span>
      </div>
      <input id="inpStop" type="text" placeholder="ex: le, la, de, pour" />
    </div>

    <div class="grow">
      <div class="label-row">
        <label>Mots à ne pas modifier</label>
        <span class="tip" tabindex="0" data-tip="Liste séparée par des virgules. Ces mots ne seront pas traduits / transformés.">?</span>
      </div>
      <input id="inpExc" type="text" placeholder="ex: curus, en-us..." />
    </div>
  </div>

  <div class="row" style="margin-top:10px">
    <div class="grow">
      <div class="label-row">
        <label>Expressions multi-mots</label>
        <span class="tip" tabindex="0" data-tip="Liste séparée par des virgules. Permet de garder des expressions comme un seul bloc (ex: 'air max').">?</span>
      </div>
      <input id="inpMulti" type="text" placeholder="ex: bleu-marine, maillot-de-bain" />
    </div>

    <div class="grow">
      <div class="label-row">
        <label>Regex référence</label>
        <span class="tip" tabindex="0" data-tip="Permet de détecter une référence produit dans l’URL. Exemple : ref-AB1234.">?</span>
      </div>
      <input id="inpRegex" type="text" value="(?i)ref[:\\- ]?([a-z0-9\\-]+)" />
    </div>

    <div class="grow">
      <div class="label-row">
        <label>Score minimum</label>
        <span class="tip" tabindex="0" data-tip="Info : ce seuil ne bloque pas les résultats. Il sert uniquement d’indication.">?</span>
      </div>
      <input id="inpMin" type="number" step="0.1" value="0.5" />
    </div>
  </div>

  <div class="row" style="margin-top:10px">
    <div class="grow">
      <div class="label-row">
        <label>Importance du sens dans le résultat</label>
        <span class="tip" tabindex="0" data-tip="Plus la valeur est élevée, plus l’outil se base sur le sens des mots (plutôt que sur la ressemblance exacte).">?</span>
      </div>
      <input id="inpSemanticWeight" type="number" step="1" value="80" />
    </div>

    <div class="grow">
      <div class="label-row">
        <label>Bonus si les mêmes mots apparaissent</label>
        <span class="tip" tabindex="0" data-tip="Ajoute des points pour chaque mot présent à la fois dans l’URL à corriger et l’URL proposée.">?</span>
      </div>
      <input id="inpTokenBonus" type="number" step="1" value="5" />
    </div>

    <div class="grow">
      <div class="label-row">
        <label>Pénalité si l’URL proposée ajoute des mots</label>
        <span class="tip" tabindex="0" data-tip="Retire des points pour chaque mot présent dans l’URL proposée mais absent de l’URL à corriger (valeur négative attendue).">?</span>
      </div>
      <input id="inpTokenMalus" type="number" step="1" value="-10" />
    </div>
  </div>

  <div style="margin-top:14px">
    <div class="section-title" style="margin-bottom:8px">
      Listes de mots (bonus / pénalité)
      <span
        class="tip"
        tabindex="0"
        data-tip="Ajuste l’importance de chaque liste. 'Utiliser' active le filtrage automatique basé sur cette liste."
      >?</span>
    </div>

    <div class="table-wrap">
      <table id="tblDico">
        <thead>
          <tr>
            <th>Liste</th>
            <th style="width:130px">Bonus</th>
            <th style="width:130px">Pénalité</th>
            <th style="width:120px">Utiliser</th>
            <th style="width:140px">Entrées</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</details>

<div style="margin-top:14px;display:flex;gap:10px;flex-wrap:wrap;align-items:center">
  <button class="btn ghost" id="btnApply">Appliquer</button>
  <span id="cfgStatus" class="badge info hidden"></span>
</div>

        </div>
      </section>

      <!-- Panel: Test URL -->
      <section id="panel-test" class="tab-panel">
  <div class="card">
    <div class="section-title">Diagnostic URL</div>
    <div class="sub">Teste comment l’outil comprend et transforme une URL.</div>

    <div class="row" style="margin-top:12px;align-items:flex-end">
      <div class="grow">
        <label>URL</label>
        <input id="testUrl" type="text" placeholder="https://www.exemple.com/produit/ref-AB1234?color=red">
      </div>
      <button class="btn primary" id="btnTest">Tester</button>
    </div>

    <div style="margin-top:12px">
      <label>Résultat</label>
      <textarea id="testOut" readonly style="min-height:160px"></textarea>
    </div>
  </div>
</section>

      <!-- Panel: Matching -->
<section id="panel-matching" class="tab-panel">
  <div class="card">
    <div class="section-title">Traitement</div>
    <div class="sub">
      Importe les URLs à corriger et les URLs valides (validés à l’import), puis lance le traitement.
      Le résultat est stocké dans ton historique.
    </div>

    <div class="row" style="margin-top:14px">
  <div class="grow">
    <div class="label-row">
      <label>
        Fichier des URLs à corriger (onglet <code>404</code>, colonne <code>URL_404</code>)
      </label>
      <span
        class="tip"
        tabindex="0"
        data-tip="Format attendu : un fichier Excel (.xlsx/.xls) avec un onglet nommé 404. La ligne 1 doit contenir l’en-tête URL_404. Ensuite, 1 URL par ligne (sans cellules fusionnées)."
      >?</span>
    </div>

    <input id="file404" type="file" accept=".xlsx,.xls" />

    <div class="sub" style="margin-top:6px">
      <a href="#" id="dl404Tpl">Télécharger le template 404</a>
    </div>

    <div id="f404Status" class="sub"></div>
  </div>

  <div class="grow">
    <div class="label-row">
      <label>
        Fichier des URLs valides (onglet <code>200</code>, colonne <code>URL_200</code>)
      </label>
      <span
        class="tip"
        tabindex="0"
        data-tip="Format attendu : un fichier Excel (.xlsx/.xls) avec un onglet nommé 200. La ligne 1 doit contenir l’en-tête URL_200. Ensuite, 1 URL par ligne (sans cellules fusionnées)."
      >?</span>
    </div>

    <input id="file200" type="file" accept=".xlsx,.xls" />

    <div class="sub" style="margin-top:6px">
      <a href="#" id="dl200Tpl">Télécharger le template 200</a>
    </div>

    <div id="f200Status" class="sub"></div>
  </div>
</div>

    <div style="margin-top:14px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end">
      <span id="runStatus" class="badge info hidden"></span>
      <button class="btn ghost" id="btnClear" type="button">Réinitialiser</button>
      <button class="btn primary" id="btnRun" type="button">Lancer</button>
    </div>

    <!-- Progress -->
    <div id="progressWrap" class="hidden" style="margin-top:12px">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px">
        <span id="progressLabel" class="sub" style="margin:0">Traitement…</span>
        <span id="progressPct" class="badge info">0%</span>
      </div>

      <div style="height:10px;background:#eef2ff;border:1px solid var(--border);border-radius:999px;overflow:hidden">
        <div id="progressBar" style="height:100%;width:0%"></div>
      </div>

      <div class="help" style="margin-top:8px;display:flex;gap:12px;flex-wrap:wrap">
        <span>Temps écoulé : <b id="elapsedTxt">0s</b></span>
        <span>Estimation : <b id="etaTxt">—</b></span>
      </div>
    </div>

    <!-- Download -->
    <div
      id="downloadWrap"
      class="hidden"
      style="margin-top:14px;display:flex;gap:10px;align-items:center;justify-content:flex-end;flex-wrap:wrap"
    >
      <span id="downloadLabel" class="badge ok"></span>
      <button class="btn ghost" id="btnDownload" type="button">Télécharger</button>
    </div>
  </div>
</section>


      <!-- Panel: Historique (accessible via bouton topbar) -->
      <section id="panel-history" class="tab-panel">
        <div class="card">
          <div class="section-title" style="justify-content:space-between;align-items:center;">
            <span>Historique</span>
            <div style="display:flex;gap:10px;flex-wrap:wrap">
              <button class="btn ghost mini" id="btnHistoryRefresh" type="button">Rafraîchir</button>
            </div>
          </div>
          <div class="sub">Nom du run + date + fichiers. Tu peux renommer et supprimer un run.</div>

          <div style="margin-top:12px" class="table-wrap">
            <table id="tblHistory">
              <thead>
                <tr>
                  <th style="width:220px">Date</th>
                  <th style="width:320px">Nom</th>
                  <th style="width:260px">Run</th>
                  <th style="width:260px">Fichiers</th>
                  <th style="width:340px">Actions</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <div id="historyStatus" class="sub" style="margin-top:10px"></div>
        </div>
      </section>

      <div class="footer">© Redirect Match</div>
    </div>

    <!-- Run Summary Modal -->
    <div id="runSummaryModal" class="hidden">
      <div class="rs-backdrop" id="runSummaryBackdrop"></div>

      <div class="rs-modal" role="dialog" aria-modal="true" aria-labelledby="rsTitle">
        <div class="rs-header">
          <div>
            <div id="rsTitle" class="rs-title">Récap du run</div>
            <div id="rsSubtitle" class="rs-subtitle"></div>
          </div>
          <button id="btnRunSummaryClose" class="btn ghost" type="button">Fermer</button>
        </div>

        <div class="rs-body" id="runSummaryContent"></div>

        <div class="rs-footer">
          <button id="btnRunSummaryDownload" class="btn primary" type="button">Télécharger le résultat</button>
          <button id="btnRunSummaryOk" class="btn ghost" type="button">OK</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* ============================================================
   DOM REFS + TABS/PANELS INIT EN PREMIER (FIX TDZ)
   ============================================================ */
const elGate = document.getElementById('gate');
const elLoginOpen = document.getElementById('btnLoginOpen');
const elLogout = document.getElementById('btnLogout');
const elUser = document.getElementById('currentUser');
const elHistoryTop = document.getElementById('btnHistoryTop');
const appShell = document.getElementById('appShell');

const tabs = document.querySelectorAll('.tab');
const panels = {
  config: document.getElementById('panel-config'),
  test: document.getElementById('panel-test'),
  matching: document.getElementById('panel-matching'),
  history: document.getElementById('panel-history')
};



/* ============================================================
   SUPABASE + AUTH + HASH ROUTING (#/login) + LOGOUT NON-BLOQUANT
   ============================================================ */
const supabaseClient = window.supabase.createClient(
  window.SUPABASE_URL,
  window.SUPABASE_PUBLISHABLE_KEY,
  { auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true } }
);

function setGateMsg(msg){ const el=document.getElementById('authStatus'); if(el) el.textContent=msg||''; }
function busyAuth(on){ ['btnLogin','btnSignup'].forEach(id=>{const b=document.getElementById(id); if(b) b.disabled=!!on; }); }

function openGate({ closable = true } = {}){
  elGate.classList.remove('hidden');
  appShell?.classList.add('blurred');
  const closeBtn = document.getElementById('btnGateClose');
  if(closeBtn) closeBtn.classList.toggle('hidden', !closable);
}
function closeGate(){
  elGate.classList.add('hidden');
  appShell?.classList.remove('blurred');
}

/* -------- Path routing --------
   Routes:
   - "/login" : gate non-closable + masque le shell
   - "/" : normal
*/
function getPath(){
  const p = (location.pathname || '/').replace(/\/+$/, '');
  return p === '' ? '/' : p;
}

function go(path){
  history.pushState({}, '', path);
}

function withTimeout(promise, ms = 9000){
  return Promise.race([
    promise,
    new Promise((_, reject)=> setTimeout(()=> reject(new Error('Timeout')), ms))
  ]);
}
async function getSessionSafe(){
  try{
    const { data } = await withTimeout(supabaseClient.auth.getSession(), 9000);
    return data?.session || null;
  }catch{
    return null;
  }
}

async function route(sessionOverride = null){
  const session = sessionOverride ?? await getSessionSafe();
  const authed = !!session;

  const path = getPath();

  // On n'accepte que "/" et "/login" (mais côté Vercel, les autres seront 404)
  if(path !== '/' && path !== '/login'){
    // Si jamais tu arrives ici (ex: env local sans vercel routes), on renvoie home
    history.replaceState({}, '', '/');
  }

  const finalPath = getPath();

  if(finalPath === '/login'){
    if(authed){
      history.replaceState({}, '', '/');
      appShell?.classList.remove('hidden');
      closeGate();
      return;
    }
    setGateMsg('');
    openGate({ closable: false });
    appShell?.classList.add('hidden');     // => "juste" la popup
    return;
  }

  // "/"
  appShell?.classList.remove('hidden');
  closeGate();

  // si tu veux, tu peux garder un comportement "soft" :
  // si pas connecté, tu peux laisser le front visible mais bloquer les actions via requireAuthOrGate
}

async function applyAuthUI(sessionOverride = null){
  const session = sessionOverride ?? await getSessionSafe();
  const authed = !!session;

  elUser.textContent = authed ? `Connecté : ${session.user.email}` : '';

  elLogout.classList.toggle('hidden', !authed);
  elLoginOpen.classList.toggle('hidden', authed);
  elHistoryTop.classList.toggle('hidden', !authed);

  if (authed && panels?.history?.classList.contains('active')) {
    loadHistory().catch(()=>{});
  }
}

async function requireAuthOrGate(message){
  const session = await getSessionSafe();
  if(!session){
    setGateMsg(message || 'Connecte-toi pour continuer.');
    openGate({ closable: true });
    return null;
  }
  return session;
}

/* Support tokens éventuels dans l’URL (magic link) */
(async function bootstrapFromHash(){
  const hash=new URLSearchParams(location.hash.replace('#','').split('?')[1] || '');
  const access_token=hash.get('access_token');
  const refresh_token=hash.get('refresh_token');
  if(access_token && refresh_token){
    try{ await supabaseClient.auth.setSession({access_token,refresh_token}); }
    catch{}
    finally{
      // On enlève totalement le hash (tokens + #/)
      history.replaceState({}, '', '/');
      route().catch(()=>{});
    }

  }
})();

const logoutOriginalText = elLogout?.textContent || 'Se déconnecter';
function setLogoutPending(on){
  if(!elLogout) return;
  if(on){
    elLogout.disabled = true;
    elLogout.innerHTML = '<span class="spinner"></span>Déconnexion…';
  }else{
    elLogout.disabled = false;
    elLogout.textContent = logoutOriginalText;
  }
}

/* Auth state changes */
let CURRENT_USER_ID = null;

supabaseClient.auth.onAuthStateChange(async (event, session)=> {
  if (event === 'SIGNED_IN' || event === 'SIGNED_OUT') {
    CURRENT_USER_ID = session?.user?.id || null;
    loadLocalForUser(CURRENT_USER_ID);
    hydrateUIFromState();
  } else if (event === 'TOKEN_REFRESHED') {
    CURRENT_USER_ID = session?.user?.id || CURRENT_USER_ID;
  }

  await applyAuthUI(session || null);
  await route(session || null);
});

/* Login */
document.getElementById('btnLogin')?.addEventListener('click', async ()=>{
  const email=document.getElementById('authEmail').value.trim();
  const password=document.getElementById('authPassword').value;
  if(!email||!password) return setGateMsg('Renseigne email et mot de passe.');

  setGateMsg('Connexion…'); busyAuth(true);
  try{
    const { data, error } = await withTimeout(
      supabaseClient.auth.signInWithPassword({ email, password }),
      12000
    );
    if(error) return setGateMsg('Erreur: '+error.message);

    setGateMsg('Connecté.');
    await applyAuthUI(data?.session || null);

    history.replaceState({}, '', '/');
    await route(data?.session || null);
    closeGate();

    loadHistory().catch(()=>{});

  }catch(e){
    setGateMsg('Erreur: '+(e?.message || String(e)));
  }finally{
    busyAuth(false);
  }
});

/* Signup */
document.getElementById('btnSignup')?.addEventListener('click', async ()=>{
  const email=document.getElementById('authEmail').value.trim();
  const password=document.getElementById('authPassword').value;
  if(!email||!password) return setGateMsg('Renseigne email et mot de passe (min. 6 caractères).');

  setGateMsg('Création du compte…'); busyAuth(true);
  try{
    const { error } = await withTimeout(
      supabaseClient.auth.signUp({
        email,
        password,
        options:{ emailRedirectTo: `${location.origin}/login` }
      }),
      12000
    );
    if(error) return setGateMsg('Erreur: '+error.message);
    setGateMsg('Compte créé. Vérifie ton email.');
  }catch(e){
    setGateMsg('Erreur: '+(e?.message || String(e)));
  }finally{
    busyAuth(false);
  }
});

elLoginOpen.addEventListener('click', (e)=>{
  e.preventDefault();
  setGateMsg('');
  openGate({ closable: false });
  go('/login');
  route().catch(()=>{});
});


document.getElementById('btnGateClose')?.addEventListener('click', ()=>{
  // en /login, on retourne à /
  if(getPath() === '/login'){
    history.replaceState({}, '', '/');
    appShell?.classList.remove('hidden');
    route().catch(()=>{});
    return;
  }
  closeGate();
  setGateMsg('');
});


/* Logout non-bloquant */
elLogout.addEventListener('click', async () => {
  setLogoutPending(true);

  closeGate();
  setGateMsg('');
  elUser.textContent = 'Déconnexion…';

  let accessToken = null;
  try {
    const { data } = await supabaseClient.auth.getSession();
    accessToken = data?.session?.access_token || null;
  } catch {}

  // 1) déconnexion locale immédiate
  try { await supabaseClient.auth.signOut({ scope: 'local' }); } catch {}

  // 2) reset UI/local
  hardResetUIAndLocal();

  // 3) best effort global logout
  if (accessToken) {
    const ctrl = new AbortController();
    setTimeout(() => ctrl.abort(), 6000);
    fetch(`${window.SUPABASE_URL}/auth/v1/logout?scope=global`, {
      method: 'POST',
      headers: {
        apikey: window.SUPABASE_PUBLISHABLE_KEY,
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json;charset=UTF-8'
      },
      signal: ctrl.signal
    }).catch(() => {});
  }

  setLogoutPending(false);
  elUser.textContent = '';
  elLogout.classList.add('hidden');
  elLoginOpen.classList.remove('hidden');
  elHistoryTop.classList.add('hidden');

  CURRENT_USER_ID = null;
  history.replaceState({}, '', '/');
  await route(null).catch(()=>{});
});

/* ============================================================
   UI TABS / PANELS
   ============================================================ */
function openPanel(name){
  Object.values(panels).forEach(p=>p.classList.remove('active'));
  if(panels[name]) panels[name].classList.add('active');

  tabs.forEach(x=>x.classList.remove('active'));
  const btn = document.querySelector(`.tab[data-tab="${name}"]`);
  if(btn) btn.classList.add('active');

  if(name === 'history') loadHistory().catch(()=>{});
}
tabs.forEach(t=> t.addEventListener('click',()=>openPanel(t.dataset.tab)));

elHistoryTop?.addEventListener('click', async ()=>{
  const session = await requireAuthOrGate('Connecte-toi pour accéder à ton historique.');
  if(!session) return;
  openPanel('history');
});

window.addEventListener('popstate', async ()=>{
  await route().catch(()=>{});
});


/* ============================================================
   MODALS
   ============================================================ */
const modal = document.getElementById('modal');
const mTitle = document.getElementById('mTitle');
const mSubtitle = document.getElementById('mSubtitle');
const mBody = document.getElementById('mBody');
const mFoot = document.getElementById('mFoot');
const mClose = document.getElementById('mClose');
const mBackdrop = document.getElementById('mBackdrop');

function closeModal(){ modal?.classList.add('hidden'); }
mClose?.addEventListener('click', closeModal);
mBackdrop?.addEventListener('click', closeModal);

function escapeHtml(s){
  return String(s ?? '')
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'",'&#039;');
}

function showAlert({ title='Attention', subtitle='', html='' }){
  if(!modal) return alert(title);
  mTitle.textContent = title;
  mSubtitle.textContent = subtitle || '';
  mBody.innerHTML = html || '';
  mFoot.innerHTML = `<button class="btn primary" type="button" id="mOk">OK</button>`;
  modal.classList.remove('hidden');
  document.getElementById('mOk')?.addEventListener('click', closeModal);
}

function showConfirm({ title='Confirmer', subtitle='', html='', confirmText='Confirmer', danger=false }){
  return new Promise((resolve)=>{
    mTitle.textContent = title;
    mSubtitle.textContent = subtitle || '';
    mBody.innerHTML = html || '';
    mFoot.innerHTML = `
      <button class="btn ghost" type="button" id="mCancel">Annuler</button>
      <button class="btn ${danger?'danger':'primary'}" type="button" id="mConfirm">${escapeHtml(confirmText)}</button>
    `;
    modal.classList.remove('hidden');

    const done = (v)=>{ closeModal(); resolve(v); };
    document.getElementById('mCancel')?.addEventListener('click', ()=>done(false), { once:true });
    document.getElementById('mConfirm')?.addEventListener('click', ()=>done(true), { once:true });
  });
}

function showPrompt({ title='Nom', subtitle='Optionnel', placeholder='Ex: Décembre - redirections', defaultValue='' }){
  return new Promise((resolve)=>{
    mTitle.textContent = title;
    mSubtitle.textContent = subtitle || '';
    mBody.innerHTML = `
      <div style="display:grid;gap:10px">
        <div class="help">Tu peux laisser vide.</div>
        <input id="mInput" type="text" placeholder="${escapeHtml(placeholder)}" value="${escapeHtml(defaultValue)}">
      </div>
    `;
    mFoot.innerHTML = `
      <button class="btn ghost" type="button" id="mSkip">Ignorer</button>
      <button class="btn primary" type="button" id="mSave">Enregistrer</button>
    `;
    modal.classList.remove('hidden');

    const input = ()=> document.getElementById('mInput')?.value?.trim() || '';
    const done = (v)=>{ closeModal(); resolve(v); };

    document.getElementById('mSkip')?.addEventListener('click', ()=>done(null), { once:true });
    document.getElementById('mSave')?.addEventListener('click', ()=>done(input()), { once:true });
  });
}

/* ============================================================
   STATE + LOCAL STORAGE PER USER
   ============================================================ */
const state={
  dicos:{},
  dicoWeights:{},
  translations:{},
  parents:[],
  cfg:{
    stop:new Set(),
    exc:new Set(),
    multi:[],
    ref:'(?i)ref[:\\- ]?([a-z0-9\\-]+)',
    min:0.5,
    semanticWeight: 80,
    tokenBonus: 5,
    tokenMalus: -10
  }
};

function getSettingsKey(userId){
  return `matcherFront::${userId || 'anon'}`;
}

function resetStateOnly(){
  state.dicos = {};
  state.dicoWeights = {};
  state.translations = {};
  state.parents = [];
  state.cfg = {
    stop: new Set(),
    exc: new Set(),
    multi: [],
    ref: '(?i)ref[:\\- ]?([a-z0-9\\-]+)',
    min: 0.5,
    semanticWeight: 80,
    tokenBonus: 5,
    tokenMalus: -10
  };
}

function serializeDicos(){
  const out = {};
  for (const [name, dict] of Object.entries(state.dicos || {})) {
    out[name] = {};
    for (const [k, synSet] of Object.entries(dict || {})) {
      out[name][k] = Array.from(synSet || []);
    }
  }
  return out;
}

function deserializeDicos(raw){
  const out = {};
  for (const [name, dict] of Object.entries(raw || {})) {
    out[name] = {};
    for (const [k, arr] of Object.entries(dict || {})) {
      out[name][k] = new Set(Array.isArray(arr) ? arr : []);
    }
  }
  return out;
}

function saveLocal(){
  const key = getSettingsKey(CURRENT_USER_ID);
  localStorage.setItem(key, JSON.stringify({
    dicos: serializeDicos(),
    dicoWeights: state.dicoWeights,
    cfg: {
      stop: [...state.cfg.stop],
      exc: [...state.cfg.exc],
      multi: state.cfg.multi,
      ref: state.cfg.ref,
      min: state.cfg.min,
      semanticWeight: state.cfg.semanticWeight,
      tokenBonus: state.cfg.tokenBonus,
      tokenMalus: state.cfg.tokenMalus
    },
    translations: state.translations,
    parents: state.parents
  }));
}

function loadLocalForUser(userId){
  resetStateOnly();
  const key = getSettingsKey(userId);
  const raw = localStorage.getItem(key);

  const legacy = localStorage.getItem('matcherFront');
  const src = raw || legacy;
  if(!src) return;

  try{
    const obj = JSON.parse(src);

    state.dicos = deserializeDicos(obj.dicos || {});
    state.dicoWeights = obj.dicoWeights || {};

    state.cfg.stop = new Set(obj?.cfg?.stop || []);
    state.cfg.exc = new Set(obj?.cfg?.exc || []);
    state.cfg.multi = obj?.cfg?.multi || [];
    state.cfg.ref = obj?.cfg?.ref || state.cfg.ref;
    state.cfg.min = obj?.cfg?.min ?? 0.5;

    state.cfg.semanticWeight = Number(obj?.cfg?.semanticWeight ?? 80);
    if(!Number.isFinite(state.cfg.semanticWeight)) state.cfg.semanticWeight = 80;

    state.cfg.tokenBonus = Number(obj?.cfg?.tokenBonus ?? 5);
    if(!Number.isFinite(state.cfg.tokenBonus)) state.cfg.tokenBonus = 5;

    state.cfg.tokenMalus = Number(obj?.cfg?.tokenMalus ?? -10);
    if(!Number.isFinite(state.cfg.tokenMalus)) state.cfg.tokenMalus = -10;

    state.translations = obj.translations || {};
    state.parents = obj.parents || [];

    for (const name of Object.keys(state.dicos || {})) {
      if (!state.dicoWeights[name]) {
        state.dicoWeights[name] = { bonus: 1, malus: 1, active: true };
      }
    }

    if(!raw && legacy){
      localStorage.setItem(key, src);
    }
  }catch{}
}

/* ============================================================
   DOM REFS (rest)
   ============================================================ */
const fileDico=document.getElementById('fileDico');
const fileTrad=document.getElementById('fileTrad');
const fileParents=document.getElementById('fileParents');

const dicoStatus=document.getElementById('dicoStatus');
const tradStatus=document.getElementById('tradStatus');
const parentsStatus=document.getElementById('parentsStatus');

const inpStop=document.getElementById('inpStop');
const inpExc=document.getElementById('inpExc');
const inpMulti=document.getElementById('inpMulti');
const inpRegex=document.getElementById('inpRegex');
const inpMin=document.getElementById('inpMin');

const inpSemanticWeight=document.getElementById('inpSemanticWeight');
const inpTokenBonus=document.getElementById('inpTokenBonus');
const inpTokenMalus=document.getElementById('inpTokenMalus');

const btnApply=document.getElementById('btnApply');
const cfgStatus=document.getElementById('cfgStatus');

const testUrl=document.getElementById('testUrl');
const btnTest=document.getElementById('btnTest');
const testOut=document.getElementById('testOut');

const file404=document.getElementById('file404');
const file200=document.getElementById('file200');
const f404Status=document.getElementById('f404Status');
const f200Status=document.getElementById('f200Status');

function downloadUrlTemplate(kind){
  // kind: '404' ou '200'
  const sheetName = kind;
  const col = (kind === '404') ? 'URL_404' : 'URL_200';

  const example =
    (kind === '404')
      ? 'https://www.exemple.com/ancienne-url'
      : 'https://www.exemple.com/nouvelle-url';

  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet([
    [col],
    [example]
  ]);

  XLSX.utils.book_append_sheet(wb, ws, sheetName);
  XLSX.writeFile(wb, `template_${kind}.xlsx`);
}

document.getElementById('dl404Tpl')?.addEventListener('click', (e)=>{
  e.preventDefault();
  downloadUrlTemplate('404');
});

document.getElementById('dl200Tpl')?.addEventListener('click', (e)=>{
  e.preventDefault();
  downloadUrlTemplate('200');
});


const btnRun=document.getElementById('btnRun');
const btnClear=document.getElementById('btnClear');
const runStatus=document.getElementById('runStatus');

const tblDico=document.querySelector('#tblDico tbody');
const prefilterBadge=document.getElementById('prefilterBadge');

/* Progress DOM */
const progressWrap = document.getElementById('progressWrap');
const progressLabel = document.getElementById('progressLabel');
const progressPct = document.getElementById('progressPct');
const progressBar = document.getElementById('progressBar');
const elapsedTxt = document.getElementById('elapsedTxt');
const etaTxt = document.getElementById('etaTxt');

/* Download UI */
const downloadWrap = document.getElementById('downloadWrap');
const btnDownload = document.getElementById('btnDownload');
const downloadLabel = document.getElementById('downloadLabel');

const tblHistory = document.getElementById('tblHistory');
const tblHistoryBody = tblHistory?.querySelector('tbody');
const historyStatus = document.getElementById('historyStatus');
const btnHistoryRefresh = document.getElementById('btnHistoryRefresh');

/* Summary Modal */
const runSummaryModal = document.getElementById('runSummaryModal');
const runSummaryContent = document.getElementById('runSummaryContent');
const rsSubtitle = document.getElementById('rsSubtitle');
const btnRunSummaryClose = document.getElementById('btnRunSummaryClose');
const btnRunSummaryOk = document.getElementById('btnRunSummaryOk');
const btnRunSummaryDownload = document.getElementById('btnRunSummaryDownload');
const runSummaryBackdrop = document.getElementById('runSummaryBackdrop');

function openRunSummaryModal(){ runSummaryModal?.classList.remove('hidden'); }

/* Demande de nom après récap */
let pendingRunToName = null;         // { userId, runId, createdAt }
let namingAskedForRunId = null;

async function closeRunSummaryModal(){
  runSummaryModal?.classList.add('hidden');

  if(pendingRunToName && namingAskedForRunId !== pendingRunToName.runId){
    namingAskedForRunId = pendingRunToName.runId;

    const newName = await showPrompt({
      title:'Nom du run',
      subtitle:'Optionnel (après le récap)',
      placeholder:'Ex: Redirections - Semaine 52',
      defaultValue:''
    });

    if(newName !== null){
      try{
        const { userId, runId, createdAt } = pendingRunToName;
        const metaPath = `${userId}/runs/${runId}/meta.json`;
        await overwriteJson(metaPath, { name: newName || '', created_at: createdAt || new Date().toISOString() });

        if(panels.history.classList.contains('active')) {
          await loadHistory();
        }
      }catch(err){
        showAlert({ title:'Erreur', subtitle:'Enregistrement du nom', html: escapeHtml(err?.message || String(err)) });
      }
    }

    pendingRunToName = null;
  }
}

btnRunSummaryClose?.addEventListener('click', ()=>{ closeRunSummaryModal().catch(()=>{}); });
btnRunSummaryOk?.addEventListener('click', ()=>{ closeRunSummaryModal().catch(()=>{}); });
runSummaryBackdrop?.addEventListener('click', ()=>{ closeRunSummaryModal().catch(()=>{}); });

/* ============================================================
   INIT UI FROM STATE + RESET
   ============================================================ */
function hydrateUIFromState(){
  if(inpStop) inpStop.value = [...state.cfg.stop].join(', ');
  if(inpExc) inpExc.value = [...state.cfg.exc].join(', ');
  if(inpMulti) inpMulti.value = state.cfg.multi.join(', ');
  if(inpRegex) inpRegex.value = state.cfg.ref;
  if(inpMin) inpMin.value = String(state.cfg.min);

  if(inpSemanticWeight) inpSemanticWeight.value = String(state.cfg.semanticWeight ?? 80);
  if(inpTokenBonus) inpTokenBonus.value = String(state.cfg.tokenBonus ?? 5);
  if(inpTokenMalus) inpTokenMalus.value = String(state.cfg.tokenMalus ?? -10);

  if(tradStatus) tradStatus.textContent = Object.keys(state.translations||{}).length ? `${Object.keys(state.translations).length} traduction(s).` : '';
  if(parentsStatus) parentsStatus.textContent = (state.parents||[]).length ? `${state.parents.length} URL(s) parent.` : '';

  renderDicoTable();
  updatePrefilterBadge();
}

function hardResetUIAndLocal(){
  try{
    localStorage.removeItem(getSettingsKey(CURRENT_USER_ID));
    localStorage.removeItem('matcherFront');
  }catch{}

  resetStateOnly();

  if(fileDico) fileDico.value = '';
  if(fileTrad) fileTrad.value = '';
  if(fileParents) fileParents.value = '';
  if(file404) file404.value = '';
  if(file200) file200.value = '';

  if(dicoStatus) dicoStatus.textContent = '';
  if(tradStatus) tradStatus.textContent = '';
  if(parentsStatus) parentsStatus.textContent = '';
  if(f404Status) f404Status.textContent = '';
  if(f200Status) f200Status.textContent = '';

  if(inpStop) inpStop.value = '';
  if(inpExc) inpExc.value = '';
  if(inpMulti) inpMulti.value = '';
  if(inpRegex) inpRegex.value = state.cfg.ref;
  if(inpMin) inpMin.value = String(state.cfg.min);

  if(inpSemanticWeight) inpSemanticWeight.value = '80';
  if(inpTokenBonus) inpTokenBonus.value = '5';
  if(inpTokenMalus) inpTokenMalus.value = '-10';

  resetDownloadUI();
  clearRunStatus();
  stopTimeBasedProgress();
  stopElapsedTimer();
  uiProgressHide();

  pendingRunToName = null;
  namingAskedForRunId = null;

  renderDicoTable();
  updatePrefilterBadge();

  openPanel('config');
}

/* ============================================================
   RUN STATUS + DOWNLOAD LOCAL
   ============================================================ */
let resultBlobUrl = null;
let resultFilename = 'result.csv';
let lastResultBlob = null;

function setRunStatus(kind, text){
  if(!runStatus) return;
  runStatus.classList.remove('hidden');
  runStatus.className = 'badge ' + (kind || 'info');
  runStatus.textContent = text || '';
}
function clearRunStatus(){
  runStatus?.classList.add('hidden');
  runStatus.textContent = '';
}

function resetDownloadUI() {
  if (resultBlobUrl) {
    URL.revokeObjectURL(resultBlobUrl);
    resultBlobUrl = null;
  }
  lastResultBlob = null;
  resultFilename = 'result.csv';
  downloadWrap.classList.add('hidden');
  downloadLabel.textContent = '';
}

btnDownload.addEventListener('click', () => {
  if (!resultBlobUrl) return;
  const a = document.createElement('a');
  a.href = resultBlobUrl;
  a.download = resultFilename || 'result.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
});

/* ============================================================
   PROGRESS (elapsed + ETA + time-based progress)
   ============================================================ */
let progressTimer = null;
let timeProgressTimer = null;
let runStartTs = 0;

function fmtSeconds(totalSec){
  const s = Math.max(0, Math.floor(totalSec));
  if(s < 60) return `${s}s`;
  const m = Math.floor(s / 60);
  const r = s % 60;
  return `${m}m ${r}s`;
}

function loadAvgRunSeconds(){
  try{
    const raw = localStorage.getItem('matcherAvgRunSeconds');
    const n = Number(raw);
    return Number.isFinite(n) && n > 0 ? n : null;
  }catch{ return null; }
}
function saveRunSeconds(seconds){
  const sec = Number(seconds);
  if(!Number.isFinite(sec) || sec <= 0) return;
  const old = loadAvgRunSeconds();
  const next = old == null ? sec : (old * 0.7 + sec * 0.3);
  try{ localStorage.setItem('matcherAvgRunSeconds', String(next)); }catch{}
}

/* avg sec per 404 */
function loadAvgSecPer404(){
  try{
    const raw = localStorage.getItem('matcherAvgSecPer404');
    const n = Number(raw);
    return Number.isFinite(n) && n > 0 ? n : null;
  }catch{ return null; }
}
function saveAvgSecPer404(elapsedSec, nb404){
  const sec = Number(elapsedSec);
  const n404 = Number(nb404);
  if(!Number.isFinite(sec) || sec <= 0) return;
  if(!Number.isFinite(n404) || n404 <= 0) return;

  const per = sec / n404;
  const old = loadAvgSecPer404();
  const next = old == null ? per : (old * 0.7 + per * 0.3);
  try{ localStorage.setItem('matcherAvgSecPer404', String(next)); }catch{}
}
function estimateTargetSeconds(nb404){
  const per = loadAvgSecPer404();
  if(per != null){
    return Math.max(10, Math.min(12 * 60, per * nb404));
  }
  const avg = loadAvgRunSeconds();
  return Math.max(10, Math.min(12 * 60, avg ?? 60));
}

function uiProgressShow(){
  if(!progressWrap) return;
  progressWrap.classList.remove('hidden');
  if(progressLabel) progressLabel.textContent = 'Traitement…';
  if(progressPct){ progressPct.className = 'badge info'; progressPct.textContent = '0%'; }
  if(progressBar) progressBar.style.width = '0%';
  if(elapsedTxt) elapsedTxt.textContent = '0s';
  if(etaTxt) etaTxt.textContent = '—';
}
function uiProgressHide(){
  if(!progressWrap) return;
  progressWrap.classList.add('hidden');
  if(progressBar) progressBar.style.width = '0%';
  if(progressPct) progressPct.textContent = '0%';
  if(elapsedTxt) elapsedTxt.textContent = '0s';
  if(etaTxt) etaTxt.textContent = '—';
}
function setProgress(p){
  const pct = Math.max(0, Math.min(100, Math.floor(p)));
  if(progressBar) progressBar.style.width = pct + '%';
  if(progressPct) progressPct.textContent = pct + '%';
}

function startElapsedTimer(targetSec = null){
  runStartTs = Date.now();
  stopElapsedTimer();
  progressTimer = setInterval(()=>{
    const elapsedSec = (Date.now() - runStartTs) / 1000;
    if(elapsedTxt) elapsedTxt.textContent = fmtSeconds(elapsedSec);

    if(targetSec != null){
      const remaining = Math.max(0, targetSec - elapsedSec);
      etaTxt.textContent = fmtSeconds(remaining);
    } else {
      etaTxt.textContent = '—';
    }
  }, 250);
}
function stopElapsedTimer(){
  if(progressTimer){ clearInterval(progressTimer); progressTimer = null; }
}

function startTimeBasedProgress(targetSec = 60){
  stopTimeBasedProgress();
  setProgress(0);

  const target = Math.max(10, targetSec);

  timeProgressTimer = setInterval(() => {
    const elapsedSec = (Date.now() - runStartTs) / 1000;

    let p;
    if (elapsedSec <= target) p = (elapsedSec / target) * 95;
    else {
      const extra = elapsedSec - target;
      p = 95 + (1 - Math.exp(-extra / target)) * 4;
    }
    p = Math.min(99, p);
    setProgress(p);
  }, 250);
}
function stopTimeBasedProgress(){
  if(timeProgressTimer){
    clearInterval(timeProgressTimer);
    timeProgressTimer = null;
  }
}
function finishProgressOK(){
  stopTimeBasedProgress();
  setProgress(100);
  if(progressPct){ progressPct.className = 'badge ok'; progressPct.textContent = '100%'; }
  if(progressLabel) progressLabel.textContent = 'Terminé';
}
function finishProgressError(){
  stopTimeBasedProgress();
  if(progressPct){ progressPct.className = 'badge err'; progressPct.textContent = 'Erreur'; }
  if(progressLabel) progressLabel.textContent = 'Erreur';
}

/* ============================================================
   FILE INPUT: allow re-import same file (reset on click)
   ============================================================ */
function enableFileReimport(inputEl){
  if(!inputEl) return;
  inputEl.addEventListener('click', ()=>{ inputEl.value=''; });
}
enableFileReimport(fileDico);
enableFileReimport(fileTrad);
enableFileReimport(fileParents);
enableFileReimport(file404);
enableFileReimport(file200);

/* ============================================================
   CONFIG APPLY
   ============================================================ */
inpStop.value=[...state.cfg.stop].join(', ');
inpExc.value=[...state.cfg.exc].join(', ');
inpMulti.value=state.cfg.multi.join(', ');
inpRegex.value=state.cfg.ref;
inpMin.value=state.cfg.min;

inpSemanticWeight.value = String(state.cfg.semanticWeight ?? 80);
inpTokenBonus.value = String(state.cfg.tokenBonus ?? 5);
inpTokenMalus.value = String(state.cfg.tokenMalus ?? -10);

btnApply.addEventListener('click',()=>{
  state.cfg.stop=new Set(inpStop.value.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean));
  state.cfg.exc=new Set(inpExc.value.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean));
  state.cfg.multi=inpMulti.value.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
  state.cfg.ref=inpRegex.value.trim()||state.cfg.ref;
  state.cfg.min=Number(inpMin.value)||0.5;

  state.cfg.semanticWeight = Number(inpSemanticWeight.value);
  if(!Number.isFinite(state.cfg.semanticWeight)) state.cfg.semanticWeight = 80;

  state.cfg.tokenBonus = Number(inpTokenBonus.value);
  if(!Number.isFinite(state.cfg.tokenBonus)) state.cfg.tokenBonus = 5;

  state.cfg.tokenMalus = Number(inpTokenMalus.value);
  if(!Number.isFinite(state.cfg.tokenMalus)) state.cfg.tokenMalus = -10;

  saveLocal();

  cfgStatus.classList.remove('hidden');
  cfgStatus.className = 'badge ok';
  cfgStatus.textContent = 'Paramètres enregistrés';
  setTimeout(()=>cfgStatus.classList.add('hidden'), 1600);
});

/* ============================================================
   API BASE (Cloud Run direct)
   ============================================================ */
const PROD_API_BASE = "https://url-matcher-70649262164.europe-west1.run.app";
const DEV_API_BASE  = "https://url-matcher-70649262164.europe-west1.run.app";
const MATCH_ENDPOINT = "/match";

function isLocalHost(){
  const h = location.hostname;
  return h === 'localhost' || h === '127.0.0.1';
}
function buildUrl(path){
  const p = path.startsWith('/') ? path : '/' + path;
  const base = isLocalHost() ? DEV_API_BASE : PROD_API_BASE;
  return base.replace(/\/$/, '') + p;
}

/* ============================================================
   EXCEL HELPERS + VALIDATIONS
   ============================================================ */
async function readExcel(file){
  return new Promise((resolve,reject)=>{
    const reader=new FileReader();
    reader.onload=e=>{
      try{ const wb=XLSX.read(new Uint8Array(e.target.result),{type:'array'}); resolve(wb); }
      catch(err){ reject(err); }
    };
    reader.onerror=reject;
    reader.readAsArrayBuffer(file);
  });
}

function findSheet(wb, wanted){
  if(!wb) return null;
  const exact = wb.Sheets[wanted];
  if(exact) return exact;
  const sname = wb.SheetNames.find(n => String(n).trim().toLowerCase() === String(wanted).trim().toLowerCase());
  return sname ? wb.Sheets[sname] : null;
}

function sheetColumnsAsSet(sheet){
  const rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });
  if(!rows.length) return new Set();
  return new Set(Object.keys(rows[0] || {}).map(k=>String(k).trim()));
}

function assertColumns({ sheet, required, context }){
  const cols = sheetColumnsAsSet(sheet);
  const missing = required.filter(r => !cols.has(r));
  if(missing.length){
    showAlert({
      title: 'Fichier invalide',
      subtitle: context || '',
      html: `
        <div>Colonnes manquantes :</div>
        <ul>
          ${missing.map(m=>`<li><b>${escapeHtml(m)}</b></li>`).join('')}
        </ul>
        <div class="help">Vérifie l’en-tête (ligne 1) et le nom des colonnes.</div>
      `
    });
    return false;
  }
  return true;
}

async function validate404File(file){
  const wb = await readExcel(file);
  const sh = findSheet(wb, '404');
  if(!sh){
    showAlert({
      title:'Fichier des URLs à corriger invalide',
      subtitle:'Il faut un onglet nommé “404”.',
      html:`<div class="help">Ton fichier doit contenir un onglet <b>404</b> avec une colonne <b>URL_404</b>.</div>`
    });
    return false;
  }
  return assertColumns({ sheet: sh, required:['URL_404'], context:'URLs à corriger → colonne URL_404' });
}

async function validate200File(file){
  const wb = await readExcel(file);
  const sh = findSheet(wb, '200');
  if(!sh){
    showAlert({
      title:'Fichier des URLs valides invalide',
      subtitle:'Il faut un onglet nommé “200”.',
      html:`<div class="help">Ton fichier doit contenir un onglet <b>200</b> avec une colonne <b>URL_200</b>.</div>`
    });
    return false;
  }
  return assertColumns({ sheet: sh, required:['URL_200'], context:'URLs valides → colonne URL_200' });
}

async function validateTradFile(file){
  const wb = await readExcel(file);
  for(const name of wb.SheetNames){
    const sh = wb.Sheets[name];
    const cols = sheetColumnsAsSet(sh);
    if(cols.has('SOURCE') && cols.has('TRANSLATION')) return true;
  }
  showAlert({
    title:'Traductions invalides',
    subtitle:'Colonnes attendues : SOURCE, TRANSLATION',
    html:`<div class="help">Dans au moins un onglet, il faut les colonnes <b>SOURCE</b> et <b>TRANSLATION</b>.</div>`
  });
  return false;
}

async function validateParentsFile(file){
  const wb = await readExcel(file);
  for(const name of wb.SheetNames){
    const sh = wb.Sheets[name];
    const cols = sheetColumnsAsSet(sh);
    if(cols.has('URL')) return true;
  }
  showAlert({
    title:'Parents invalides',
    subtitle:'Colonne attendue : URL',
    html:`<div class="help">Dans au moins un onglet, il faut une colonne <b>URL</b>.</div>`
  });
  return false;
}

async function validateDicoFile(file){
  const wb = await readExcel(file);
  let totalHeaders = 0;
  for(const name of wb.SheetNames){
    const sh = wb.Sheets[name];
    const grid = XLSX.utils.sheet_to_json(sh, { header:1, blankrows:false });
    const headers = (grid?.[0] || []).map(x=>String(x||'').trim()).filter(Boolean);
    totalHeaders += headers.length;
  }
  if(totalHeaders <= 0){
    showAlert({
      title:'Listes de mots invalides',
      subtitle:'En-têtes vides',
      html:`<div class="help">La première ligne doit contenir les noms des listes (colonnes).</div>`
    });
    return false;
  }
  return true;
}

async function extractUrlsFrom404File(file){
  const wb = await readExcel(file);
  const sh = findSheet(wb, '404');
  const rows = XLSX.utils.sheet_to_json(sh, { defval: "" });
  return rows
    .map(r => String(r.URL_404 ?? '').trim())
    .filter(Boolean);
}

async function extractUrlsFrom200File(file){
  const wb = await readExcel(file);
  const sh = findSheet(wb, '200');
  const rows = XLSX.utils.sheet_to_json(sh, { defval: "" });
  return rows
    .map(r => String(r.URL_200 ?? '').trim())
    .filter(Boolean);
}

/* ============================================================
   DICTIONARY TABLE + PREFILTER BADGE
   ============================================================ */
function updatePrefilterBadge(){
  const active = Object.keys(state.dicoWeights || {}).filter(n => (state.dicoWeights[n] || {}).active);
  if(active.length>0){
    prefilterBadge.textContent='Filtrage : activé';
    prefilterBadge.className='badge ok';
    prefilterBadge.title='Au moins une liste utilisée : le filtrage automatique est appliqué.';
  } else {
    prefilterBadge.textContent='Filtrage : désactivé';
    prefilterBadge.className='badge info';
    prefilterBadge.title='Active une liste pour appliquer le filtrage automatique.';
  }
}

function renderDicoTable(){
  if(!tblDico) return;
  tblDico.innerHTML='';
  const names=Object.keys(state.dicos || {});
  if(names.length===0){
    const tr=document.createElement('tr'); const td=document.createElement('td');
    td.colSpan=5; td.textContent='Aucune liste chargée.'; td.style.color='var(--muted)'; td.style.fontWeight='900';
    tr.appendChild(td); tblDico.appendChild(tr);
    updatePrefilterBadge();
    return;
  }

  names.forEach(name=>{
    if(!state.dicoWeights[name]){
      state.dicoWeights[name] = { bonus:1, malus:1, active:true };
    }
  });

  names.forEach(name=>{
    const dict=state.dicos[name];
    const w=state.dicoWeights[name] || {bonus:1,malus:1,active:true};
    const entries=Object.keys(dict).length;

    const tr=document.createElement('tr');
    tr.innerHTML=`
      <td style="font-weight:950">${escapeHtml(name)}</td>
      <td><input type="number" step="0.1" value="${escapeHtml(w.bonus)}" data-k="bonus" style="width:100%;padding:8px;border:1px solid var(--border);border-radius:12px;background:#fff"></td>
      <td><input type="number" step="0.1" value="${escapeHtml(w.malus)}" data-k="malus" style="width:100%;padding:8px;border:1px solid var(--border);border-radius:12px;background:#fff"></td>
      <td><input class="switch" type="checkbox" ${w.active?'checked':''} data-k="active"></td>
      <td>${entries.toLocaleString('fr-FR')}</td>
    `;
    tr.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('change',()=>{
        const key=inp.dataset.k;
        const row=state.dicoWeights[name]||{bonus:1,malus:1,active:true};
        if(key==='active') row.active=inp.checked;
        else row[key]=Number(inp.value);
        state.dicoWeights[name]=row;
        saveLocal();
        updatePrefilterBadge();
      });
    });
    tblDico.appendChild(tr);
  });

  saveLocal();
  updatePrefilterBadge();
}
renderDicoTable();

/* ============================================================
   IMPORT FILES (validated at import)
   ============================================================ */
fileDico.addEventListener('change', async ()=>{
  if(!fileDico.files?.[0]) return;
  try{
    const ok = await validateDicoFile(fileDico.files[0]);
    if(!ok){ fileDico.value=''; dicoStatus.textContent=''; return; }

    const wb=await readExcel(fileDico.files[0]);
    state.dicos={};

    wb.SheetNames.forEach(sheetName=>{
      const sh=wb.Sheets[sheetName];
      const df=XLSX.utils.sheet_to_json(sh,{header:1,blankrows:false});
      if(!df.length) return;

      const cols=df[0].map((_,i)=>df.map(row=>row[i]));
      cols.forEach((col,idx)=>{
        const dicoName=String(df[0][idx]||`Dico_${idx+1}`).trim();
        if(!dicoName) return;

        if(!state.dicos[dicoName]) state.dicos[dicoName]={};

        for(let r=1;r<col.length;r++){
          const cell=col[r];
          if(cell==null) continue;
          const items=String(cell).split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
          if(!items.length) continue;
          const key=items[0];
          state.dicos[dicoName][key]=(state.dicos[dicoName][key]||new Set());
          items.forEach(x=>state.dicos[dicoName][key].add(x));
        }
      });
    });

    for (const name of Object.keys(state.dicos || {})) {
      if (!state.dicoWeights[name]) {
        state.dicoWeights[name] = { bonus: 1, malus: 1, active: true };
      }
    }

    saveLocal();
    renderDicoTable();
    dicoStatus.textContent = `${Object.keys(state.dicos).length} liste(s) chargée(s).`;
  }catch(e){
    fileDico.value='';
    dicoStatus.textContent='';
    showAlert({ title:'Erreur', subtitle:'Lecture des listes de mots', html: escapeHtml(e?.message||String(e)) });
  }
});

fileTrad.addEventListener('change', async ()=>{
  if(!fileTrad.files?.[0]) return;
  try{
    const ok = await validateTradFile(fileTrad.files[0]);
    if(!ok){ fileTrad.value=''; tradStatus.textContent=''; return; }

    const wb=await readExcel(fileTrad.files[0]);
    state.translations={};

    wb.SheetNames.forEach(name=>{
      const sh=wb.Sheets[name];
      const arr=XLSX.utils.sheet_to_json(sh, { defval: "" });
      arr.forEach(row=>{
        const s=String(row['SOURCE']||'').trim().toLowerCase();
        const t=String(row['TRANSLATION']||'').trim().toLowerCase();
        if(s) state.translations[s]=t;
      });
    });

    saveLocal();
    tradStatus.textContent = `${Object.keys(state.translations).length} traduction(s).`;
  }catch(e){
    fileTrad.value='';
    tradStatus.textContent='';
    showAlert({ title:'Erreur', subtitle:'Lecture des traductions', html: escapeHtml(e?.message||String(e)) });
  }
});

fileParents.addEventListener('change', async ()=>{
  if(!fileParents.files?.[0]) return;
  try{
    const ok = await validateParentsFile(fileParents.files[0]);
    if(!ok){ fileParents.value=''; parentsStatus.textContent=''; return; }

    const wb=await readExcel(fileParents.files[0]);
    state.parents=[];

    wb.SheetNames.forEach(name=>{
      const sh=wb.Sheets[name];
      const arr=XLSX.utils.sheet_to_json(sh, { defval: "" });
      arr.forEach(row=>{
        if(row.URL) state.parents.push(String(row.URL));
      });
    });

    saveLocal();
    parentsStatus.textContent = `${state.parents.length} URL(s) parent.`;
  }catch(e){
    fileParents.value='';
    parentsStatus.textContent='';
    showAlert({ title:'Erreur', subtitle:'Lecture des parents', html: escapeHtml(e?.message||String(e)) });
  }
});

file404.addEventListener('change', async ()=>{
  if(!file404.files?.[0]) return;
  try{
    const ok = await validate404File(file404.files[0]);
    if(!ok){ file404.value=''; f404Status.textContent=''; return; }
    f404Status.textContent = `OK (${file404.files[0].name})`;
  }catch(e){
    file404.value='';
    f404Status.textContent='';
    showAlert({ title:'Erreur', subtitle:'Lecture du fichier des URLs à corriger', html: escapeHtml(e?.message||String(e)) });
  }
});

file200.addEventListener('change', async ()=>{
  if(!file200.files?.[0]) return;
  try{
    const ok = await validate200File(file200.files[0]);
    if(!ok){ file200.value=''; f200Status.textContent=''; return; }
    f200Status.textContent = `OK (${file200.files[0].name})`;
  }catch(e){
    file200.value='';
    f200Status.textContent='';
    showAlert({ title:'Erreur', subtitle:'Lecture du fichier des URLs valides', html: escapeHtml(e?.message||String(e)) });
  }
});

/* ============================================================
   BUILD CONFIG (payload API)
   ============================================================ */
function buildConfigFromUI(){
  const dictionaries = Object.entries(state.dicos).map(([name, dict]) => ({
    name,
    rows: Object.entries(dict).map(([k, synSet]) => [k, ...Array.from(synSet)].join(','))
  }));

  const bonus = {}, malus = {}, prefilter = {};

  for (const name of Object.keys(state.dicos || {})) {
    if (!state.dicoWeights[name]) state.dicoWeights[name] = { bonus: 1, malus: 1, active: true };
  }

  Object.keys(state.dicos || {}).forEach((name)=>{
    const w = state.dicoWeights[name] || { bonus: 1, malus: 1, active: true };
    bonus[name] = Number.isFinite(Number(w.bonus)) ? Number(w.bonus) : 1;
    malus[name] = Number.isFinite(Number(w.malus)) ? Number(w.malus) : 1;
    prefilter[name] = !!w.active;
  });

  return {
    stopwords: [...state.cfg.stop],
    exceptions: [...state.cfg.exc],
    multi: state.cfg.multi,
    refRegex: state.cfg.ref,
    translations: Object.entries(state.translations || {}).map(([SOURCE, TRANSLATION]) => ({ SOURCE, TRANSLATION })),
    dictionaries,
    bonus,
    malus,
    prefilter,
    scoreMin: state.cfg.min,
    parents: state.parents || [],
    embeddingWeight: state.cfg.semanticWeight,
    tokenBonusIdentical: state.cfg.tokenBonus,
    tokenPenaltyExtra: state.cfg.tokenMalus
  };
}

/* ============================================================
   DIAGNOSTIC URL
   ============================================================ */
function formatDictHits(hits){
  if(!hits || typeof hits !== 'object') return null;
  const lines = [];
  Object.entries(hits).forEach(([dicoName, v])=>{
    if(v == null) return;
    if(Array.isArray(v)){
      if(v.length) lines.push(`Liste ${dicoName} : ${v.join(', ')}`);
    } else if(typeof v === 'string'){
      const s = v.trim();
      if(s) lines.push(`Liste ${dicoName} : ${s}`);
    } else if(typeof v === 'object'){
      const keys = Object.keys(v).filter(k => !!v[k]);
      if(keys.length) lines.push(`Liste ${dicoName} : ${keys.join(', ')}`);
    }
  });
  return lines.length ? lines : null;
}

btnTest.addEventListener('click', async () => {
  const url = testUrl.value.trim();
  if (!url) { testOut.value = 'Veuillez saisir une URL.'; return; }

  try {
    const payload = { url, config: buildConfigFromUI() };

    const session = await getSessionSafe();
    const token = session?.access_token;
    if (!token) throw new Error("Tu dois être connecté(e) pour utiliser cette fonction.");

    const ctrl = new AbortController();
    setTimeout(()=>ctrl.abort(), 15000);

    const r = await fetch(buildUrl('/debug-url'), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
      body: JSON.stringify(payload),
      signal: ctrl.signal
    });

    if (!r.ok) throw new Error('Une erreur est survenue pendant le traitement. Réessaie dans quelques instants.');
    const j = await r.json();

    const out = [];
    out.push(`URL saisie : ${j.input}`);
    out.push(`URL simplifiée : ${j.clean}`);
    out.push(`URL après remplacement des termes : ${j.substituted}`);
    out.push(`Mots détectés : ${j.tokens?.length ? j.tokens.join(', ') : 'Aucun'}`);
    out.push(j.reference ? `Référence détectée : ${j.reference}` : 'Aucune référence détectée.');

    const hits = j.dict_hits || j.dico_hits || j.characteristics || j.dictionaries || null;
    const lines = formatDictHits(hits);

    out.push('');
    if (lines) {
      out.push('Mots reconnus dans tes listes :');
      lines.forEach(x => out.push(' - ' + x));
    } else {
      out.push('Mots reconnus dans tes listes : aucun mot détecté (ou information non disponible).');
    }

    testOut.value = out.join('\n');
  } catch (e) {
    testOut.value = 'Erreur : ' + (e?.message || String(e));
  }
});

/* ============================================================
   SUMMARY MODAL
   ============================================================ */
function toNumberSafe(v){
  const raw = String(v ?? '').trim();
  if(!raw) return NaN;

  const s = raw
    .replace('%', '')
    .replace(/\s+/g, '')
    .replace(',', '.');

  let n = Number(s);
  if(!Number.isFinite(n)) return NaN;

  return n;
}

async function buildRunSummaryFromBlob(blob){
  const text = await blob.text();
  const wb = XLSX.read(text, { type: 'string' });
  const sh = wb.Sheets[wb.SheetNames[0]];
  const rows = XLSX.utils.sheet_to_json(sh, { defval: "" });

  const total = rows.length;
  const scoreKey = "SCORE_TOTAL";
  const url404Key = "URL_404";
  const url200Key = "URL_200_PROPOSEE";


  const scored = rows
    .map((r) => ({
      score: toNumberSafe(r[scoreKey]),
      url404: String(r[url404Key] ?? ''),
      url200: String(r[url200Key] ?? '')
    }))
    .filter(x => Number.isFinite(x.score));

  // Tri décroissant (meilleurs en haut)
  scored.sort((a,b)=> b.score - a.score);

  const nScored = scored.length;

  // Zone à vérifier = 10% les plus faibles (sur les lignes avec score)
  const k = Math.max(1, Math.floor(nScored * 0.10));
  const startIndex = Math.max(0, nScored - k);

  // Excel: +1 (1-based) +1 (header)
  const startLineExcel = startIndex + 2;

  // Scores les plus bas (range du groupe à vérifier)
  const bottom = scored.slice(startIndex); // les k plus faibles (car tri desc)
  const bottomMin = bottom.length ? Math.min(...bottom.map(x=>x.score)) : null;
  const bottomMax = bottom.length ? Math.max(...bottom.map(x=>x.score)) : null;

  // Top 5 meilleurs matchings (scores les plus élevés)
  const best5 = scored.slice(0, 5);

  return { total, k, startLineExcel, bottomMin, bottomMax, best5 };
}

function renderRunSummary(summary){
  const { total, k, startLineExcel, bottomMin, bottomMax, best5 } = summary;

  const minTxt = (bottomMin == null) ? 'n/a' : `${bottomMin.toFixed(2)}`;
  const maxTxt = (bottomMax == null) ? 'n/a' : `${bottomMax.toFixed(2)}`;


  if(rsSubtitle) {
    rsSubtitle.textContent = `Top 5 meilleurs matchings + zone de contrôle (10% scores les plus faibles).`;
  }

  const tableRows = (best5 || []).map((x, idx) => {
    const s = x.score.toFixed(2);
    return `
      <tr>
        <td>${idx + 1}</td>
        <td><b>${s}</b></td>
        <td class="rs-url">${escapeHtml(x.url404)}</td>
        <td class="rs-url">${escapeHtml(x.url200)}</td>
      </tr>
    `;
  }).join('');

  runSummaryContent.innerHTML = `
    <div class="rs-kpis">
      <div class="rs-kpi">
        <div class="label">URLs traitées</div>
        <div class="value">${Number(total).toLocaleString('fr-FR')}</div>
        <div class="hint">Total lignes (hors en-tête)</div>
      </div>

      <div class="rs-kpi">
        <div class="label">URLs à vérifier</div>
        <div class="value">${Number(k).toLocaleString('fr-FR')}</div>
        <div class="hint">scores les plus faibles</div>
      </div>

      <div class="rs-kpi">
        <div class="label">Scores les plus bas</div>
        <div class="value">${minTxt}</div>
        <div class="hint">Plage à vérifier : ${minTxt} → ${maxTxt}</div>
      </div>
    </div>

    <div class="rs-callout">
      <div><b>Zone à vérifier</b> (scores les plus bas : ${minTxt} → ${maxTxt})</div>
      <div style="margin-top:6px">
        URLs à vérifier à partir de la ligne ${Number(startLineExcel).toLocaleString('fr-FR')}
        (in Excel après tri décroissant de <b>SCORE_TOTAL</b>).
      </div>
    </div>

    <div class="card" style="padding:0;border-radius:12px;box-shadow:none;border:1px solid var(--border)">
      <div style="padding:12px 12px 0 12px;font-weight:950">Top 5 meilleurs matchings</div>
      <div style="padding:10px 12px 12px 12px;color:var(--muted);font-size:12px">
        Les scores les plus élevés (échantillon de matchings “bons”).
      </div>

      <div style="padding:0 12px 12px 12px">
        <table class="rs-table">
          <thead>
            <tr>
              <th style="width:55px">#</th>
              <th style="width:90px">Score</th>
              <th>URL à corriger</th>
              <th>URL proposée</th>
            </tr>
          </thead>
          <tbody>
            ${tableRows || `<tr><td colspan="4" style="color:var(--muted);padding:12px">Aucune donnée.</td></tr>`}
          </tbody>
        </table>
      </div>
    </div>
  `;
}

btnRunSummaryDownload?.addEventListener('click', () => {
  if (!resultBlobUrl) return;
  const a = document.createElement('a');
  a.href = resultBlobUrl;
  a.download = resultFilename || 'result.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
});

/* ============================================================
   STORAGE (Supabase bucket) + HISTORY
   ============================================================ */
const STORAGE_BUCKET = 'matcher-results';

function tsForRunId(){
  const iso = new Date().toISOString();
  return iso.slice(0,19).replace('T','_').replace(/:/g,'-');
}
function rand4(){ return Math.random().toString(16).slice(2,6); }
function makeRunId(){ return `${tsForRunId()}_${rand4()}`; }

function resultContentType(){
  return 'text/csv; charset=utf-8';
}
function extFromFile(file){
  const n = (file?.name || '').toLowerCase();
  if(n.endsWith('.xlsx')) return 'xlsx';
  if(n.endsWith('.xls')) return 'xls';
  return 'xlsx';
}
function prettyRunDate(runId){
  const parts = String(runId || '').split('_');
  if(parts.length < 2) return runId;
  const d = parts[0];
  const t = parts[1].replace(/-/g,':');
  return `${d} ${t}`;
}

async function storageSignedDownload(path, suggestedName){
  const { data, error } = await supabaseClient.storage
    .from(STORAGE_BUCKET)
    .createSignedUrl(path, 60);
  if(error) throw error;

  const a = document.createElement('a');
  a.href = data.signedUrl;
  a.download = suggestedName || path.split('/').pop();
  document.body.appendChild(a);
  a.click();
  a.remove();
}

async function uploadOne(path, fileOrBlob, contentType){
  const { error } = await supabaseClient.storage
    .from(STORAGE_BUCKET)
    .upload(path, fileOrBlob, { contentType: contentType || undefined, upsert: false });
  if(error) throw error;
}

async function overwriteJson(path, obj){
  try{ await supabaseClient.storage.from(STORAGE_BUCKET).remove([path]); }catch{}
  const blob = new Blob([JSON.stringify(obj)], { type:'application/json' });
  await uploadOne(path, blob, 'application/json');
}

async function uploadRunFolder({ userId, runId, resultBlob, dicoFile, tradFile, parentsFile, runName, createdAt }) {
  const base = `${userId}/runs/${runId}`;

  await uploadOne(`${base}/result.csv`, resultBlob, resultContentType());

  if(dicoFile){
    const ext = extFromFile(dicoFile);
    await uploadOne(
      `${base}/dico.${ext}`,
      dicoFile,
      dicoFile.type || (ext === 'xls'
        ? 'application/vnd.ms-excel'
        : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    );
  }
  if(tradFile){
    const ext = extFromFile(tradFile);
    await uploadOne(
      `${base}/trad.${ext}`,
      tradFile,
      tradFile.type || (ext === 'xls'
        ? 'application/vnd.ms-excel'
        : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    );
  }
  if(parentsFile){
    const ext = extFromFile(parentsFile);
    await uploadOne(
      `${base}/parents.${ext}`,
      parentsFile,
      parentsFile.type || (ext === 'xls'
        ? 'application/vnd.ms-excel'
        : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    );
  }

  await overwriteJson(`${base}/meta.json`, {
    name: runName || '',
    created_at: createdAt || new Date().toISOString()
  });

  return base;
}

function renderHistoryEmpty(message){
  if(tblHistoryBody){
    tblHistoryBody.innerHTML = `
      <tr>
        <td colspan="5" style="color:var(--muted);font-weight:900">${escapeHtml(message || 'Aucun élément.')}</td>
      </tr>
    `;
  }
  if(historyStatus) historyStatus.textContent = '';
}

function badgeForFile(name){
  const n = String(name||'').toLowerCase();
  if(n.startsWith('result')) return `<span class="badge ok">result</span>`;
  if(n.startsWith('dico')) return `<span class="badge info">listes</span>`;
  if(n.startsWith('trad')) return `<span class="badge info">trad</span>`;
  if(n.startsWith('parents')) return `<span class="badge info">parents</span>`;
  if(n.startsWith('meta')) return `<span class="badge warn">meta</span>`;
  return `<span class="badge info">${escapeHtml(name)}</span>`;
}

function makeActionBtn(label, attrs = {}, kind='ghost'){
  const data = Object.entries(attrs).map(([k,v])=>`data-${k}="${encodeURIComponent(String(v))}"`).join(' ');
  return `<button class="btn ${kind} mini" type="button" ${data} style="margin-right:6px;margin-top:6px">${escapeHtml(label)}</button>`;
}

async function fetchMetaNameSigned(path){
  const { data: signed, error } = await supabaseClient.storage.from(STORAGE_BUCKET).createSignedUrl(path, 60);
  if(error) return '';
  try{
    const r = await fetch(signed.signedUrl);
    if(!r.ok) return '';
    const j = await r.json();
    return String(j?.name || '').trim();
  }catch{
    return '';
  }
}

async function loadHistory(){
  const session = await getSessionSafe();
  if(!session){
    renderHistoryEmpty('Connecte-toi pour voir ton historique.');
    return;
  }

  const userId = session.user.id;
  if(historyStatus) historyStatus.textContent = 'Chargement…';

  if(!tblHistoryBody) return;

  const { data: items, error } = await supabaseClient.storage
    .from(STORAGE_BUCKET)
    .list(`${userId}/runs`, { limit: 200, sortBy: { column: 'name', order: 'desc' } });

  if(error){
    renderHistoryEmpty('Impossible d’accéder à l’historique pour le moment. Réessaie plus tard.');
    if(historyStatus) historyStatus.textContent = '';
    return;
  }

  const folders = (items || []).filter(it => it?.id == null && it?.name);
  const runIds = folders.map(f=>f.name).filter(Boolean);

  if(!runIds.length){
    renderHistoryEmpty('Aucun run pour l’instant.');
    if(historyStatus) historyStatus.textContent = '';
    return;
  }

  async function listFilesInRun(runId){
    const { data, error } = await supabaseClient.storage
      .from(STORAGE_BUCKET)
      .list(`${userId}/runs/${runId}`, { limit: 80, sortBy: { column: 'name', order: 'asc' } });
    if(error) return { runId, files: [], metaName: '', error };
    const files = (data || []).filter(x => x?.id !== null);
    return { runId, files, metaName:'', error:null };
  }

  const maxConcurrent = 6;
  const listed = [];
  for(let i=0;i<runIds.length;i+=maxConcurrent){
    const chunk = runIds.slice(i, i+maxConcurrent);
    const res = await Promise.all(chunk.map(listFilesInRun));
    listed.push(...res);
  }

  for(const r of listed){
    const meta = r.files.find(f => String(f.name||'').toLowerCase() === 'meta.json');
    if(meta){
      const path = `${userId}/runs/${r.runId}/meta.json`;
      r.metaName = await fetchMetaNameSigned(path);
    } else {
      r.metaName = '';
    }
  }

  tblHistoryBody.innerHTML = '';
  listed.forEach(r=>{
    const runId = r.runId;
    const base = `${userId}/runs/${runId}`;
    const files = r.files || [];
    const fileNames = files.map(f => f.name);

    const filesBadges = fileNames.length
      ? fileNames.filter(n=>String(n).toLowerCase()!=='meta.json').map(badgeForFile).join(' ')
      : `<span class="badge err">vide</span>`;

    let actions = '';
    if(fileNames.some(n => n.toLowerCase().startsWith('result'))){
      actions += makeActionBtn('Télécharger résultat', { action:'download', path:`${base}/result.csv`, filename:'result.csv' });
    }

    const dico = fileNames.find(n => n.toLowerCase().startsWith('dico.'));
    const trad = fileNames.find(n => n.toLowerCase().startsWith('trad.'));
    const parents = fileNames.find(n => n.toLowerCase().startsWith('parents.'));

    if(dico) actions += makeActionBtn('Listes', { action:'download', path:`${base}/${dico}`, filename:dico });
    if(trad) actions += makeActionBtn('Trad', { action:'download', path:`${base}/${trad}`, filename:trad });
    if(parents) actions += makeActionBtn('Parents', { action:'download', path:`${base}/${parents}`, filename:parents });

    actions += makeActionBtn('Renommer', { action:'rename', runid: runId }, 'ghost');
    actions += makeActionBtn('Supprimer', { action:'deleteRun', runid: runId }, 'danger');

    const tr = document.createElement('tr');
tr.innerHTML = `
  <td>${escapeHtml(prettyRunDate(runId))}</td>

  <td>
    <div style="display:grid;gap:6px">
      <div>
        <span class="badge info nowrap ellipsis" title="${escapeHtml(r.metaName || 'Sans nom')}">
          ${escapeHtml(r.metaName || 'Sans nom')}
        </span>
      </div>

      <input
        type="text"
        value="${escapeHtml(r.metaName || '')}"
        data-field="name"
        data-runid="${escapeHtml(runId)}"
        placeholder="Sans nom"
      >

      <div class="help">Modifie et clique sur “Renommer”.</div>
    </div>
  </td>

  <td>
    <span class="badge info nowrap mono ellipsis" title="${escapeHtml(runId)}">
      ${escapeHtml(runId)}
    </span>
  </td>

  <td>${filesBadges}</td>
  <td>${actions}</td>
`;
tblHistoryBody.appendChild(tr);

  });

  if(historyStatus) historyStatus.textContent = `${listed.length} run(s).`;
}

btnHistoryRefresh?.addEventListener('click', ()=> loadHistory().catch(()=>{}));

/* Delegation actions history */
tblHistoryBody?.addEventListener('click', async (e)=>{
  const btn = e.target.closest('button');
  if(!btn) return;

  const action = decodeURIComponent(btn.dataset.action || '');
  const session = await requireAuthOrGate('Connecte-toi pour accéder à ton historique.');
  if(!session) return;

  const userId = session.user.id;

  if(action === 'download'){
    const path = decodeURIComponent(btn.dataset.path || '');
    const filename = decodeURIComponent(btn.dataset.filename || '');
    try{
      await storageSignedDownload(path, filename);
    }catch(err){
      showAlert({ title:'Erreur', subtitle:'Téléchargement', html: escapeHtml(err?.message || String(err)) });
    }
    return;
  }

  if(action === 'rename'){
    const runId = decodeURIComponent(btn.dataset.runid || '');
    if(!runId) return;

    const input = tblHistoryBody.querySelector(`input[data-field="name"][data-runid="${CSS.escape(runId)}"]`);
    const current = (input?.value || '').trim();

    const newName = await showPrompt({
      title: 'Renommer le run',
      subtitle: 'Ce nom s’affiche dans l’historique.',
      placeholder: 'Ex: Novembre - redirections',
      defaultValue: current
    });
    if(newName === null) return;

    try{
      const metaPath = `${userId}/runs/${runId}/meta.json`;
      await overwriteJson(metaPath, { name: newName || '', created_at: new Date().toISOString() });
      await loadHistory();
    }catch(err){
      showAlert({ title:'Erreur', subtitle:'Renommage', html: escapeHtml(err?.message || String(err)) });
    }
    return;
  }

  if(action === 'deleteRun'){
    const runId = decodeURIComponent(btn.dataset.runid || '');
    if(!runId) return;

    const ok = await showConfirm({
      title: 'Supprimer ce run ?',
      subtitle: 'Action irréversible',
      html: `<div>Le run <b>${escapeHtml(runId)}</b> et ses fichiers seront supprimés.</div>`,
      confirmText: 'Supprimer',
      danger: true
    });
    if(!ok) return;

    try{
      const { data, error } = await supabaseClient.storage
        .from(STORAGE_BUCKET)
        .list(`${userId}/runs/${runId}`, { limit: 200 });

      if(error) throw error;
      const files = (data || []).filter(x => x?.name).map(x => `${userId}/runs/${runId}/${x.name}`);
      if(files.length){
        const { error: delErr } = await supabaseClient.storage.from(STORAGE_BUCKET).remove(files);
        if(delErr) throw delErr;
      }
      await loadHistory();
    }catch(err){
      showAlert({ title:'Erreur', subtitle:'Suppression', html: escapeHtml(err?.message || String(err)) });
    }
    return;
  }
});

/* ============================================================
   MATCHING: RUN
   ============================================================ */
async function runMatching({ file404, file200, config, token }){
  const ctrl = new AbortController();
  const timeoutMs = 59 * 60 * 1000;
  const t = setTimeout(()=>ctrl.abort(), timeoutMs);

  try{
    const fd = new FormData();
    fd.append('file404', file404, file404.name);
    fd.append('file200', file200, file200.name);
    fd.append('config', JSON.stringify(config));

    const r = await fetch(buildUrl(MATCH_ENDPOINT), {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${token}` },
      body: fd,
      signal: ctrl.signal
    });

    if(!r.ok){
      let msg = `Erreur API (${r.status})`;
      try{
        const j = await r.json();
        if (Array.isArray(j?.detail)) {
          msg = j.detail.map(d => `${(d.loc||[]).join('.')} : ${d.msg}`).join('\n');
        } else {
          msg = j?.error || j?.message || msg;
        }
      }catch{}
      throw new Error(msg);
    }

    const blob = await r.blob();
    return blob;
  } finally {
    clearTimeout(t);
  }
}

btnClear.addEventListener('click', ()=>{
  file404.value=''; file200.value='';
  f404Status.textContent=''; f200Status.textContent='';
  clearRunStatus();
  uiProgressHide();
  stopElapsedTimer();
  stopTimeBasedProgress();
  resetDownloadUI();
  pendingRunToName = null;
  namingAskedForRunId = null;
});

btnRun.addEventListener('click', async ()=>{
  resetDownloadUI();
  clearRunStatus();

  const session = await requireAuthOrGate('Connecte-toi pour lancer un matching.');
  if(!session) return;

  const f404 = file404.files?.[0];
  const f200 = file200.files?.[0];

  if(!f404 || !f200){
    showAlert({
      title:'Fichiers manquants',
      subtitle:'Il faut 2 fichiers',
      html:`<div class="help">Importe un fichier <b>404</b> (onglet 404 / URL_404) et un fichier <b>200</b> (onglet 200 / URL_200).</div>`
    });
    return;
  }

  try{
    if(!(await validate404File(f404))) return;
    if(!(await validate200File(f200))) return;
  }catch(e){
    showAlert({ title:'Erreur', subtitle:'Validation des fichiers', html: escapeHtml(e?.message||String(e)) });
    return;
  }

  let urls404 = [], urls200 = [];
  try{
    setRunStatus('info', 'Lecture des fichiers…');
    urls404 = await extractUrlsFrom404File(f404);
    urls200 = await extractUrlsFrom200File(f200);
  }catch(e){
    setRunStatus('err', 'Erreur lecture fichiers');
    showAlert({ title:'Erreur', subtitle:'Lecture des fichiers Excel', html: escapeHtml(e?.message||String(e)) });
    return;
  }

  if(!urls404.length || !urls200.length){
    showAlert({
      title:'Fichiers vides',
      subtitle:'Aucune URL détectée',
      html:`<div class="help">Vérifie que les colonnes <b>URL_404</b> et <b>URL_200</b> contiennent des valeurs.</div>`
    });
    return;
  }

  const token = session.access_token;
  const config = buildConfigFromUI();

  const targetSec = estimateTargetSeconds(urls404.length);

  uiProgressShow();
  startElapsedTimer(targetSec);
  startTimeBasedProgress(targetSec);

  setRunStatus('info', `Matching en cours… (${urls404.length} URLs 404 / ${urls200.length} URLs 200)`);

  btnRun.disabled = true;
  btnClear.disabled = true;

  const runId = makeRunId();
  const createdAt = new Date().toISOString();

  try{
    const blob = await runMatching({ file404: f404, file200: f200, config, token });

    lastResultBlob = blob;
    resultFilename = `result_${runId}.csv`;
    resultBlobUrl = URL.createObjectURL(blob);

    downloadLabel.textContent = 'Résultat prêt';
    downloadWrap.classList.remove('hidden');

    setRunStatus('info', 'Sauvegarde dans l’historique…');

    await uploadRunFolder({
      userId: session.user.id,
      runId,
      resultBlob: blob,
      dicoFile: fileDico.files?.[0] || null,
      tradFile: fileTrad.files?.[0] || null,
      parentsFile: fileParents.files?.[0] || null,
      runName: '',
      createdAt
    });

    const elapsedSec = (Date.now() - runStartTs) / 1000;
    saveRunSeconds(elapsedSec);
    saveAvgSecPer404(elapsedSec, urls404.length);

    finishProgressOK();
    setRunStatus('ok', 'Terminé. Résultat enregistré.');

    pendingRunToName = { userId: session.user.id, runId, createdAt };
    namingAskedForRunId = null;

    try{
      const summary = await buildRunSummaryFromBlob(blob);
      renderRunSummary(summary);
      openRunSummaryModal();
    }catch{
      await closeRunSummaryModal().catch(()=>{});
    }

    if(panels.history.classList.contains('active')) loadHistory().catch(()=>{});
  }catch(e){
    finishProgressError();
    setRunStatus('err', 'Erreur pendant le matching');
    showAlert({ title:'Erreur', subtitle:'Matching', html: escapeHtml(e?.message||String(e)) });
  }finally{
    stopElapsedTimer();
    btnRun.disabled = false;
    btnClear.disabled = false;
  }
});

/* ============================================================
   INITIAL BOOT
   ============================================================ */
(async function boot(){


  const session = await getSessionSafe();
  CURRENT_USER_ID = session?.user?.id || null;
  loadLocalForUser(CURRENT_USER_ID);
  hydrateUIFromState();

  await applyAuthUI(session || null);
  await route(session || null);
})();
</script>
</body>
</html>
